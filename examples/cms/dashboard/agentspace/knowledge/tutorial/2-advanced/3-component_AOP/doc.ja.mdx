axii では、複雑な UI をコンポーネントとしてカプセル化し、それらを組み合わせて使用することがよくあります。しかし、単純なネスト構造であっても、しばしば以下のような問題が起こります：  
- 子コンポーネント内の複数の DOM ノードや特定のプロパティを、親コンポーネントで設定・利用できるように公開する必要がある。  
- プロパティをレイヤーごとに透過させたり増やしたりすると、「意味のない」中間レイヤーが生じてコンポーネント構造が複雑化してしまう。  

この問題を解決するため、axii は「AOP ライク」な機能を提供しています。これにより、親コンポーネントが直接子コンポーネント内部に"侵入"し、内部の DOM や子コンポーネントを柔軟に**上書き**したり**パッチをあてたり**することができます。こうしてコンポーネントのカプセル化を維持しつつ、必要に応じてプロパティやイベントを透過させる作業を簡略化できます。

## コアアイデア

axii の実装では、`ComponentHost` が渡されたプロパティを解析します。もしプロパティ名が `$` で始まっていた場合、axii はそれを本コンポーネントの通常のプロパティではなく、子コンポーネントや子要素に対する「設定」として扱います。  
設定では、コロン (`:`) の後ろの部分が適用対象のプロパティやメソッドを表します。例えば：  
- `$xxx:style` は、`as=xxx` として定義された要素にインライン `style` を追加する  
- `$xxx:value` は、`as=xxx` として定義された要素に `value` を設定（通常は `<input>` などで使用）  
- `$xxx:style_` は、カスタムのマージロジックを利用してスタイルをより柔軟に上書きできる  
- `$xxx:children` は、指定ノードの子要素を置き換える  
- `$xxx:_props` は、内部のノードやコンポーネントのすべてのプロパティに対して一括処理を行い、カスタムのマージロジックをサポートする  

ソースコード上では、これら `$` で始まるプロパティはすべて収集され、`itemConfig` にマージされます。最終的に描画（レンダリング）される段階で、各 DOM ノードや子コンポーネントに対してこれらの設定が適用される仕組みです。つまり、以下のように親コンポーネントで指定できます：

```tsx
/ @jsx createElement /
import { atom, RenderContext } from "axii"
import { Child } from "./Child.js";
export function App({}, { createElement }: RenderContext) {
    const name = atom('world')
    return (
        <Child
            // 将子组件中 "as=root" 的元素添加一个 style
            $root:style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}
            // 给 as=main 的 <input> 元素绑定 atom
            $main:value={name}
            // 通过 style_ 自定义合并逻辑
            $main:style_={() => ({ border: '1px solid black', padding: '10px' })}
            // 给 "grandChild" 节点添加更多配置
            $grandChild={{
                '$root:style': { color: 'cyan' }
            }}
        />
    )
}
```


このように、子コンポーネント `Child` が内部で `as="root"`・`as="main"`・`as="grandChild"` のような複数のノードを定義している場合でも、親コンポーネントは `$` で始めるプロパティを使って、そのノードや子コンポーネントのプロパティを直接渡すあるいは上書きすることができます。

子コンポーネント `Child` は、このように簡潔に記述できます：

```tsx
/ @jsx createElement /
import { RenderContext } from "axii";
import { GrandChild } from "./GrandChild.js";
export function Child({}, { createElement }: RenderContext) {
    return (
        <div as="root">
        <input as="main" />
        <button as="trigger">Submit</button>
        <GrandChild as="grandChild" />
        </div>
    )
}
```


`GrandChild` でも同様です：

```tsx
/ @jsx createElement /
import { RenderContext } from "axii";
export function GrandChild({}, { createElement }: RenderContext) {
    return (
        <div as="root">
            this is grand child
        </div>
    )
}
```

描画結果としては、  
- `App` コンポーネント内で指定した `$root:style`、`$main:value`、`$main:style_`、および `$grandChild` の設定が、それぞれ対象となる DOM ノード／子コンポーネントにマージされる  
- `Child` や `GrandChild` には特に余分な Props の定義や透過ロジックは必要なく、設定が必要な DOM 要素や子コンポーネントに対して単に `as="xxx"` とマークしておくだけでよい  

## 実装の仕組み

ソースコード上では、主に `ComponentHost` の実装が鍵となっています：

1. コンポーネントが描画される際、axii はコンポーネントのプロパティやレンダリングコンテキスト、ライフサイクルなどを管理するために `ComponentHost` オブジェクトを作成します。  
2. 受け取ったプロパティを確認し、`$` で始まるものを**穿透設定**（別名「component AOP」）として扱います。  
3. これらの穿透設定をまとめて `itemConfig` に格納し、`as=xxx` の DOM や子コンポーネントに対しどのような処理を行うのかをマッピングします。例えば：  
   - `use` : その DOM 要素を完全に置き換えることが可能（既存の DOM を指定して差し替える）  
   - `props` : その DOM や子コンポーネントに対してプロパティをマージ  
   - `eventTarget`、`_use`、`_props` なども同様  
4. 実際に DOM や子コンポーネントを生成する段階で、`ComponentHost` はこれらの設定に基づいて、該当要素やコンポーネントへプロパティやイベントをバインドしていきます。  

これにより、親コンポーネントの実装で「スライス」的に子コンポーネントの内部に対して追加的なカスタマイズを施せます。これは、通常であれば Props をレイヤーごとに受け渡ししたり、子コンポーネント内で特定のスタイルやイベントをハードコーディングしたりする必要があった部分を大きく簡略化するものです。

## さらに活用する際の例と注意点

1. **命名衝突の回避**  
   子コンポーネントで DOM 要素や別の子コンポーネントに `as="root"` と設定しているなら、それを設定する際は `$root:xxx` のように指定します。各ノードで使う `as` は衝突しないように、かつ識別しやすい名前を付けてください。  

2. **カスタムマージロジック**  
   - `$xxx:style_={() => {...}}` のように、コールバックを通して単純な上書き合体でもない、より自由なスタイルのマージが行えます。  
   - `$xxx:[prop]_` 形式なら、特定のプロパティに対しても同様に、さらに柔軟な操作が可能です。  

3. **入れ子の設定**  
   親コンポーネントで `$grandChild` の設定を行い、その中に `$root` などの設定が含まれている場合、axii はそれをさらに `GrandChild` の内部 DOM ノードにマージしていきます。このように、複数階層で同じ仕組みを利用できます。  

4. **コンポーネント自体の Props の保持**  
   `$xxx:xxx` は子要素や子コンポーネントへの穿透設定専用です。コンポーネント自体の Props（例： `foo={atomValue}` など）はそのままコンポーネント固有のものとして扱われ、穿透ロジックによって上書きされることはありません。  

5. **DOM の柔軟な置き換えや再利用**  
   `use` を使うと、内部で生成するノードを既存の DOM に差し替えることも可能です。たとえば、サードパーティのライブラリによって生成される要素などを子コンポーネントのノードとして活用できるため、より高度な制御が可能です。  

## まとめ

このような浅い層の AOP ライクな「穿透設定」を活用することで、axii の利用者は、親コンポーネントから一度に子コンポーネントや内部 DOM の属性・イベント・スタイルなどを設定できます。さらに、もともとは子コンポーネント側に書く必要があった少し特殊な処理を "パッチ" のように注入することができ、コンポーネントのカプセル化を保ちつつ柔軟に拡張・変更が可能です。これは、React でしばしば見られる Props の頻繁な上提やコールバックの下伝などを減らし、煩雑さを大きく軽減してくれます。

ただし、この「コンポーネント AOP」的な手法は、あらゆる状況で利用することを意図したものではありません。**通常の props で要件を満たせる場合は、従来どおりのコンポーネントのカプセル化を優先するべき**です。しかし、一部の局所的な箇所で、柔軟かつ深いレベルの変更が必要なシーンでは、この仕組みによって冗長な props の受け渡しを大幅に削減でき、親コンポーネントが子コンポーネント内部を"侵入"して個別の設定を行うことが可能になります。