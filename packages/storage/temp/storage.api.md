## API Report File for "@interaqt/storage"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { BoolExp } from '@interaqt/shared';

// @public (undocumented)
export const ALL_ATTR_SYMBOL = "*";

// @public (undocumented)
export function assert(condition: any, message: string): void;

// @public (undocumented)
export class AttributeInfo {
    constructor(parentEntityName: string, attributeName: string, map: EntityToTableMap, symmetricDirection?: "source" | "target" | undefined);
    // (undocumented)
    attributeName: string;
    // (undocumented)
    get computed(): ((record: any) => any) | undefined;
    // (undocumented)
    data: ValueAttribute | RecordAttribute;
    // (undocumented)
    get field(): string | undefined;
    // (undocumented)
    get fieldType(): string | undefined;
    // (undocumented)
    getAttribute(name: string): AttributeInfo;
    // (undocumented)
    getLinkInfo(): LinkInfo;
    // (undocumented)
    getRecordInfo(): RecordInfo;
    // (undocumented)
    getReverseInfo(): AttributeInfo | undefined;
    // (undocumented)
    get isCollection(): boolean | undefined;
    // (undocumented)
    get isComputed(): false | ((record: any) => any) | undefined;
    // (undocumented)
    isLinkIsolated(): boolean;
    // (undocumented)
    isLinkManyToManySymmetric(): boolean;
    // (undocumented)
    isLinkMergedWithAttribute(): boolean;
    // (undocumented)
    isLinkMergedWithParent(): boolean;
    // (undocumented)
    isLinkSourceRelation(): boolean;
    // (undocumented)
    get isManyToMany(): boolean;
    // (undocumented)
    get isManyToOne(): boolean;
    // (undocumented)
    isMergedWithParent(): boolean;
    // (undocumented)
    get isOneToMany(): boolean;
    // (undocumented)
    get isOneToOne(): boolean;
    // (undocumented)
    get isOneToX(): boolean;
    // (undocumented)
    get isRecord(): true;
    // (undocumented)
    isRecordSource(): boolean;
    // (undocumented)
    get isReliance(): boolean | undefined;
    // (undocumented)
    get isValue(): boolean;
    // (undocumented)
    get isXToMany(): boolean;
    // (undocumented)
    get isXToOne(): boolean;
    // (undocumented)
    get linkField(): string | undefined;
    // (undocumented)
    get linkName(): string;
    // (undocumented)
    map: EntityToTableMap;
    // (undocumented)
    parentEntityName: string;
    // (undocumented)
    get recordName(): string;
    // (undocumented)
    symmetricDirection?: "source" | "target" | undefined;
    // (undocumented)
    get table(): string;
}

// @public (undocumented)
export class AttributeQuery {
    constructor(recordName: string, map: EntityToTableMap, data?: AttributeQueryData, parentRecord?: string | undefined, attributeName?: string | undefined, shouldQueryParentLinkData?: boolean | undefined);
    // (undocumented)
    attributeName?: string | undefined;
    // (undocumented)
    buildFullQueryTree(): RecordQueryTree;
    // (undocumented)
    buildXToOneQueryTree(): RecordQueryTree;
    // (undocumented)
    data: AttributeQueryData;
    // (undocumented)
    fullQueryTree: RecordQueryTree;
    // (undocumented)
    static getAttributeQueryDataForRecord(recordName: string, map: EntityToTableMap, includeSameTableReliance?: boolean, includeMergedRecordAttribute?: boolean, includeManagedRecordAttributes?: boolean, // link record 的 source/target 字段
    includeNotRelianceCombined?: boolean): AttributeQueryData;
    // (undocumented)
    getValueAndXToOneRecordFields(nameContext?: string[]): {
        tableAliasAndField: [string, string];
        nameContext: string[];
        attribute: string;
    }[];
    // (undocumented)
    id: number;
    // (undocumented)
    map: EntityToTableMap;
    // (undocumented)
    parentLinkRecordQuery?: RecordQuery;
    // (undocumented)
    parentRecord?: string | undefined;
    // (undocumented)
    recordName: string;
    // (undocumented)
    relatedRecords: RecordQuery[];
    // (undocumented)
    shouldQueryParentLinkData?: boolean | undefined;
    // (undocumented)
    valueAttributes: string[];
    // (undocumented)
    withParentLinkData(): AttributeQuery;
    // (undocumented)
    xToManyRecords: RecordQuery[];
    // (undocumented)
    get xToOneQueryTree(): RecordQueryTree;
    // (undocumented)
    xToOneRecords: RecordQuery[];
}

// @public (undocumented)
export type AttributeQueryData = AttributeQueryDataItem[];

// @public (undocumented)
export type AttributeQueryDataItem = string | AttributeQueryDataRecordItem;

// @public (undocumented)
export type AttributeQueryDataRecordItem = [string, RecordQueryData, boolean?];

// @public (undocumented)
export type Database = {
    scheme: (sql: string, name?: string) => Promise<any>;
    query: <T extends any>(sql: string, values: any[], name?: string) => Promise<T[]>;
    delete: <T extends any>(sql: string, where: any[], name?: string) => Promise<T[]>;
    insert: (sql: string, values: any[], name?: string) => Promise<EntityIdRef>;
    update: (sql: string, values: any[], idField?: string, name?: string) => Promise<EntityIdRef[]>;
    getAutoId: (recordName: string) => Promise<string>;
    parseMatchExpression?: (key: string, value: [string, any], fieldName: string, fieldType: string, isReferenceValue: boolean, getReferenceFieldValue: (v: string) => string, genPlaceholder: (name?: string) => string) => any;
    getPlaceholder?: () => (name?: string) => string;
    mapToDBFieldType: (type: string, collection?: boolean) => string;
};

// @public (undocumented)
export class DBSetup {
    constructor(entities: Entity[], relations: Relation[], database?: Database | undefined, mergeLinks?: MergeLinks);
    // (undocumented)
    assignTableAndField(): void;
    // (undocumented)
    buildMap(): void;
    // (undocumented)
    buildTables(): void;
    // (undocumented)
    combineRecordTable(mergeTarget: string, toMerge: string, link: string): string[] | undefined;
    // (undocumented)
    createLink(relationName: string, relation: Relation): LinkMapItem;
    // (undocumented)
    createLinkOfRelationAndEntity(relationEntityName: string, relationName: string, relation: Relation, isSource: boolean): LinkMapItem;
    // (undocumented)
    createRecord(entity: Entity | Relation, isRelation?: boolean): RecordMapItem;
    // (undocumented)
    createRecordToTable(item: string, table: string): void;
    // (undocumented)
    createTables(): Promise<any[]>;
    // (undocumented)
    createTableSQL(): string[];
    // (undocumented)
    database?: Database | undefined;
    // Warning: (ae-forgotten-export) The symbol "Entity" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    entities: Entity[];
    // (undocumented)
    getRecordName(rawRecord: Entity | Relation): string;
    // (undocumented)
    getRelationNameOfRelationAndEntity(relationName: string, isSource: boolean): string;
    // (undocumented)
    joinTables(joinTargetRecord: string, record: string, link: string): string[] | undefined;
    // (undocumented)
    map: MapData;
    // (undocumented)
    mergeLinks: MergeLinks;
    // (undocumented)
    mergeLog: any[];
    // (undocumented)
    mergeRecords(): void;
    // (undocumented)
    recordToTableMap: Map<string, string>;
    // Warning: (ae-forgotten-export) The symbol "Relation" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    relations: Relation[];
    // (undocumented)
    renameTableWithJoinedEntities(originTableName: string): void;
    // (undocumented)
    tables: TableData;
    // (undocumented)
    tableToRecordsMap: Map<string, Set<string>>;
}

// @public (undocumented)
export type EntityIdRef = {
    id: string;
    [ROW_ID_ATTR]?: string;
    [k: string]: any;
};

// @public (undocumented)
export class EntityQueryHandle {
    constructor(map: EntityToTableMap, database: Database);
    // (undocumented)
    addRelationById(entity: string, attribute: string, entityId: string, attributeEntityId: string, relationData?: RawEntityData, events?: MutationEvent_2[]): Promise<EntityIdRef>;
    // (undocumented)
    addRelationByNameById(relationName: string, sourceEntityId: string, targetEntityId: string, rawData?: RawEntityData, events?: MutationEvent_2[]): Promise<EntityIdRef>;
    // (undocumented)
    agent: RecordQueryAgent;
    // (undocumented)
    create(entityName: string, rawData: RawEntityData, events?: MutationEvent_2[]): Promise<EntityIdRef>;
    // (undocumented)
    createMatchFromAtom(...arg: Parameters<(typeof MatchExp)["atom"]>): BoolExp<MatchAtom>;
    // (undocumented)
    database: Database;
    // (undocumented)
    delete(entityName: string, matchExpressionData: MatchExpressionData, events?: MutationEvent_2[]): Promise<Record_2[]>;
    // (undocumented)
    find(entityName: string, matchExpressionData?: MatchExpressionData, modifierData?: ModifierData, attributeQueryData?: AttributeQueryData): Promise<Record_2[]>;
    // (undocumented)
    findOne(entityName: string, matchExpression?: MatchExpressionData, modifier?: ModifierData, attributeQuery?: AttributeQueryData): Promise<Record_2>;
    // (undocumented)
    findOneRelationByName(relationName: string, matchExpressionData: MatchExpressionData, modifierData?: ModifierData, attributeQueryData?: AttributeQueryData): Promise<Record_2>;
    // (undocumented)
    findPath(entity: string, attribute: string, entityId: string, ancestorId: string): Promise<Record_2[] | undefined>;
    // (undocumented)
    findRelationByName(relationName: string, matchExpressionData?: MatchExpressionData, modifierData?: ModifierData, attributeQueryData?: AttributeQueryData): Promise<Record_2[]>;
    // (undocumented)
    getEntityName(entity: string, attribute: string): string;
    // (undocumented)
    getRelationName(entity: string, attribute: string): string;
    // (undocumented)
    map: EntityToTableMap;
    // (undocumented)
    removeRelationByName(relationName: string, matchExpressionData: MatchExpressionData, events?: MutationEvent_2[]): Promise<void | Record_2[]>;
    // (undocumented)
    update(entity: string, matchExpressionData: MatchExpressionData, rawData: RawEntityData, events?: MutationEvent_2[]): Promise<Record_2[]>;
    // (undocumented)
    updateRelationByName(relationName: string, matchExpressionData: MatchExpressionData, rawData: RawEntityData, events?: MutationEvent_2[]): Promise<Record_2[]>;
}

// @public (undocumented)
export class EntityToTableMap {
    constructor(data: MapData);
    // (undocumented)
    data: MapData;
    // (undocumented)
    findManyToManySymmetricPath(namePath: string[]): string[] | undefined;
    // (undocumented)
    getAttributeAndSymmetricDirection(rawAttributeName: string): [string, 'source' | 'target' | undefined];
    // (undocumented)
    getAttributeData(recordName: string, attributeName: string): ValueAttribute | RecordAttribute;
    // (undocumented)
    getInfo(entityName: string, attribute: string): AttributeInfo;
    // (undocumented)
    getInfoByPath(namePath: string[]): AttributeInfo | undefined;
    // (undocumented)
    getLinkInfo(recordName: string, rawAttribute: string): LinkInfo;
    // (undocumented)
    getLinkInfoByName(linkName: string): LinkInfo;
    // (undocumented)
    getRecord(recordName: string): RecordMapItem;
    // (undocumented)
    getRecordInfo(recordName: string): RecordInfo;
    // (undocumented)
    getRecordTable(entityName: string): string;
    // (undocumented)
    getReverseAttribute(entityName: string, attribute: string): string;
    // (undocumented)
    getTableAliasAndFieldName(namePath: string[], attributeName: string, dontShrink?: boolean): [string, string, string];
    // Warning: (ae-forgotten-export) The symbol "TableAndAliasStack" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    getTableAndAliasStack(namePath: string[]): TableAndAliasStack;
    // (undocumented)
    groupAttributes(entityName: string, attributeNames: string[]): [AttributeInfo[], AttributeInfo[], AttributeInfo[]];
    // (undocumented)
    spawnManyToManySymmetricPath(namePath: string[]): [string[], string[]] | undefined;
}

// @public (undocumented)
export type FieldMatchAtom = MatchAtom & {
    isInnerQuery?: boolean;
    fieldName?: [string, string];
    fieldValue?: string;
    fieldParams?: any[];
    namePath?: string[];
    isFunctionMatch?: boolean;
};

// @public (undocumented)
export function flatten<T>(arr: (T | T[])[]): T[];

// @public (undocumented)
export const ID_ATTR = "id";

// @public (undocumented)
export function indexBy(arr: any[], key: string): any;

// @public (undocumented)
export function isRelation(relation: any): boolean;

// @public (undocumented)
export type JoinTables = {
    for: any;
    joinSource: [string, string];
    joinIdField: [string, string];
    joinTarget: [string, string];
}[];

// @public (undocumented)
export const LINK_SYMBOL = "&";

// @public (undocumented)
export class LinkInfo {
    constructor(name: string, data: LinkMapItem, map: EntityToTableMap);
    // (undocumented)
    data: LinkMapItem;
    // (undocumented)
    getAttributeName(recordName: string, attribute: string): string[];
    // (undocumented)
    isCombined(): boolean;
    // (undocumented)
    isIsolated(): boolean;
    // (undocumented)
    get isManyToMany(): boolean;
    // (undocumented)
    get isManyToOne(): boolean;
    // (undocumented)
    isMerged(): boolean;
    // (undocumented)
    isMergedToSource(): boolean;
    // (undocumented)
    isMergedToTarget(): boolean;
    // (undocumented)
    get isOneToMany(): boolean;
    // (undocumented)
    get isOneToOne(): boolean;
    // (undocumented)
    get isOneToX(): boolean;
    // (undocumented)
    isRelationSource(recordName: string, attribute: string): boolean;
    // (undocumented)
    isSourceRelation(): boolean;
    // (undocumented)
    isSymmetric(): boolean;
    // (undocumented)
    get isTargetReliance(): boolean | undefined;
    // (undocumented)
    get isXToMany(): boolean;
    // (undocumented)
    get isXToOne(): boolean;
    // (undocumented)
    map: EntityToTableMap;
    // (undocumented)
    name: string;
    // (undocumented)
    get record(): RecordMapItem;
    // (undocumented)
    get recordInfo(): RecordInfo;
    // (undocumented)
    get sourceProperty(): string;
    // (undocumented)
    get sourceRecord(): string;
    // (undocumented)
    get sourceRecordInfo(): RecordInfo;
    // (undocumented)
    get table(): string;
    // (undocumented)
    get targetProperty(): string | undefined;
    // (undocumented)
    get targetRecord(): string;
    // (undocumented)
    get targetRecordInfo(): RecordInfo;
}

// @public (undocumented)
export type LinkMapItem = {
    relType: [string, string];
    sourceRecord: string;
    sourceProperty: string;
    targetRecord: string;
    targetProperty: string | undefined;
    isSourceRelation?: boolean;
    recordName?: string;
    mergedTo?: 'source' | 'target' | 'combined';
    table?: string;
    sourceField?: string;
    targetField?: string;
    isTargetReliance?: boolean;
};

// @public (undocumented)
export type MapData = {
    records: RecordMap;
    links: LinkMap;
};

// @public (undocumented)
export type MatchAtom = {
    key: string;
    value: [string, any];
    isReferenceValue?: boolean;
};

// @public (undocumented)
export class MatchExp {
    constructor(entityName: string, map: EntityToTableMap, data?: MatchExpressionData | undefined, contextRootEntity?: string | undefined, fromRelation?: boolean | undefined);
    // (undocumented)
    and(condition: MatchAtom | MatchExp): MatchExp;
    // (undocumented)
    static atom(condition: MatchAtom): BoolExp<MatchAtom>;
    // (undocumented)
    buildFieldMatchExpression(p: PlaceholderGen, db?: Database): BoolExp<FieldMatchAtom> | null;
    // (undocumented)
    buildQueryTree(matchData: MatchExpressionData, recordQueryTree: RecordQueryTree): void;
    // (undocumented)
    contextRootEntity?: string | undefined;
    // (undocumented)
    data?: MatchExpressionData | undefined;
    // (undocumented)
    entityName: string;
    // (undocumented)
    static fromObject(condition: Object): BoolExp<MatchAtom>;
    // (undocumented)
    fromRelation?: boolean | undefined;
    // (undocumented)
    getFinalFieldName(matchAttributePath: string[]): [string, string];
    // (undocumented)
    getFinalFieldValue(isReferenceValue: boolean, key: string, value: [string, any], fieldName: string, fieldType: string | undefined, p: PlaceholderGen, db?: Database): [string, any[]];
    // (undocumented)
    getReferenceFieldValue(valueStr: string): string;
    // (undocumented)
    map: EntityToTableMap;
    // (undocumented)
    xToOneQueryTree: RecordQueryTree;
}

// @public (undocumented)
export type MatchExpressionData = BoolExp<MatchAtom>;

// @public (undocumented)
export type MergeLinks = string[];

// @public (undocumented)
export class Modifier {
    constructor(recordName: string, map: EntityToTableMap, data: ModifierData, fromRelation?: boolean | undefined);
    // (undocumented)
    data: ModifierData;
    // (undocumented)
    fromRelation?: boolean | undefined;
    // (undocumented)
    get limit(): number | undefined;
    // (undocumented)
    map: EntityToTableMap;
    // (undocumented)
    get offset(): number | undefined;
    // (undocumented)
    get orderBy(): {
        attribute: string;
        recordName: string;
        order: "ASC" | "DESC";
    }[];
    // (undocumented)
    recordName: string;
}

// @public (undocumented)
export type ModifierData = {
    orderBy?: {
        [k: string]: 'ASC' | 'DESC';
    };
    limit?: number;
    offset?: number;
};

// @public (undocumented)
type MutationEvent_2 = {
    type: "create" | 'update' | 'delete';
    recordName: string;
    id?: string;
    keys?: string[];
    record?: Record_2;
    oldRecord?: Record_2;
};
export { MutationEvent_2 as MutationEvent }

// @public (undocumented)
export class NewRecordData {
    constructor(map: EntityToTableMap, recordName: string, rawData: RawEntityData, info?: AttributeInfo | undefined);
    // (undocumented)
    combinedNewRecords: NewRecordData[];
    // (undocumented)
    combinedRecordIdRefs: NewRecordData[];
    // (undocumented)
    differentTableMergedLinkNewRecords: NewRecordData[];
    // (undocumented)
    differentTableMergedLinkRecordIdRefs: NewRecordData[];
    // (undocumented)
    entityIdAttributes: AttributeInfo[];
    // (undocumented)
    getData(): Record_2;
    // (undocumented)
    getRef(): {
        id: any;
    };
    // (undocumented)
    getSameRowFieldAndValue(oldRecord?: Omit<Record_2, 'id'>): {
        field: string;
        value: any;
    }[];
    // (undocumented)
    info?: AttributeInfo | undefined;
    // (undocumented)
    isNull(): boolean;
    // (undocumented)
    isolatedNewRecords: NewRecordData[];
    // (undocumented)
    isolatedRecordIdRefs: NewRecordData[];
    // (undocumented)
    isRef(): boolean;
    // (undocumented)
    linkRecordData?: NewRecordData;
    // (undocumented)
    map: EntityToTableMap;
    // (undocumented)
    merge(partialNewRawData: RawEntityData): NewRecordData;
    // (undocumented)
    mergedLinkTargetNewRecords: NewRecordData[];
    // (undocumented)
    mergedLinkTargetRecordIdRefs: NewRecordData[];
    // (undocumented)
    rawData: RawEntityData;
    // (undocumented)
    recordName: string;
    // (undocumented)
    relatedEntitiesData: NewRecordData[];
    // (undocumented)
    sameRowEntityIdRefs: NewRecordData[];
    // (undocumented)
    valueAttributes: AttributeInfo[];
}

// @public (undocumented)
export type PlaceholderGen = (name?: string) => string;

// @public (undocumented)
export type RawEntityData = {
    [k: string]: any;
};

// @public (undocumented)
type Record_2 = EntityIdRef & {
    [k: string]: any;
};
export { Record_2 as Record }

// @public (undocumented)
export type RecordAttribute = {
    type: 'id';
    isRecord: true;
    linkName: string;
    isSource?: boolean;
    relType: ['1' | 'n', '1' | 'n'];
    recordName: string;
    table?: string;
    field?: string;
    isReliance?: boolean;
};

// @public (undocumented)
export class RecordInfo {
    constructor(name: string, map: EntityToTableMap);
    // (undocumented)
    get allFields(): string[];
    // (undocumented)
    get combinedRecords(): AttributeInfo[];
    // (undocumented)
    data: RecordMapItem;
    // (undocumented)
    get differentTableRecordAttributes(): AttributeInfo[];
    // (undocumented)
    get differentTableReliance(): AttributeInfo[];
    // (undocumented)
    getAttributeInfo(attribute: string): AttributeInfo;
    // (undocumented)
    get idField(): string | undefined;
    // (undocumented)
    get isRelation(): boolean | undefined;
    // (undocumented)
    get JSONFields(): string[];
    // (undocumented)
    get managedRecordAttributes(): AttributeInfo[];
    // (undocumented)
    map: EntityToTableMap;
    // (undocumented)
    get mergedRecordAttributes(): AttributeInfo[];
    // (undocumented)
    name: string;
    // (undocumented)
    get notRelianceCombined(): AttributeInfo[];
    // (undocumented)
    get reliance(): AttributeInfo[];
    // (undocumented)
    get sameRowFields(): string[];
    // (undocumented)
    get sameTableReliance(): AttributeInfo[];
    // (undocumented)
    get strictRecordAttributes(): AttributeInfo[];
    // (undocumented)
    get table(): string;
    // (undocumented)
    get valueAttributes(): AttributeInfo[];
}

// @public (undocumented)
export type RecordMapItem = {
    table: string;
    attributes: {
        [k: string]: ValueAttribute | RecordAttribute;
    };
    isRelation?: boolean;
};

// @public (undocumented)
export class RecordQuery {
    constructor(recordName: string, map: EntityToTableMap, matchExpression: MatchExp, attributeQuery: AttributeQuery, modifier: Modifier, contextRootEntity?: string | undefined, parentRecord?: string | undefined, attributeName?: string | undefined, onlyRelationData?: boolean | undefined, allowNull?: boolean, label?: string | undefined, goto?: string | undefined, exit?: ((context: RecursiveContext) => Promise<boolean>) | undefined);
    // (undocumented)
    allowNull: boolean;
    // (undocumented)
    attributeName?: string | undefined;
    // (undocumented)
    attributeQuery: AttributeQuery;
    // (undocumented)
    contextRootEntity?: string | undefined;
    // (undocumented)
    static create(recordName: string, map: EntityToTableMap, data: RecordQueryData, contextRootEntity?: string, parentRecord?: string, attributeName?: string, onlyRelationData?: boolean, allowNull?: boolean): RecordQuery;
    // (undocumented)
    derive({ matchExpression, attributeQuery, modifier }: {
        matchExpression?: MatchExp;
        attributeQuery?: AttributeQuery;
        modifier?: Modifier;
    }): RecordQuery;
    // (undocumented)
    exit?: ((context: RecursiveContext) => Promise<boolean>) | undefined;
    // (undocumented)
    getData(): RecordQueryData;
    // (undocumented)
    goto?: string | undefined;
    // (undocumented)
    label?: string | undefined;
    // (undocumented)
    map: EntityToTableMap;
    // (undocumented)
    matchExpression: MatchExp;
    // (undocumented)
    modifier: Modifier;
    // (undocumented)
    onlyRelationData?: boolean | undefined;
    // (undocumented)
    parentRecord?: string | undefined;
    // (undocumented)
    recordName: string;
}

// @public (undocumented)
export class RecordQueryAgent {
    constructor(map: EntityToTableMap, database: Database);
    // (undocumented)
    addLink(linkName: string, sourceId: string, targetId: string, attributes?: RawEntityData, moveSource?: boolean, events?: MutationEvent_2[]): Promise<EntityIdRef>;
    // (undocumented)
    addLinkFromRecord(entity: string, attribute: string, entityId: string, relatedEntityId: string, attributes?: RawEntityData, events?: MutationEvent_2[]): Promise<EntityIdRef>;
    // (undocumented)
    buildFromClause(entityName: string, prefix?: string): string;
    // (undocumented)
    buildJoinClause(joinTables: JoinTables, prefix?: string): string;
    // (undocumented)
    buildModifierClause(modifier: Modifier, prefix?: string): string;
    // (undocumented)
    buildSelectClause(queryFields: ReturnType<AttributeQuery["getValueAndXToOneRecordFields"]>, prefix?: string): string;
    // (undocumented)
    buildWhereClause(fieldMatchExp: BoolExp<FieldMatchAtom> | null, prefix: string | undefined, p: PlaceholderGen): [string, any[]];
    // (undocumented)
    buildXToOneFindQuery(recordQuery: RecordQuery, prefix?: string, parentP?: PlaceholderGen): [string, any[]];
    // (undocumented)
    createRecord(newEntityData: NewRecordData, queryName?: string, events?: MutationEvent_2[]): Promise<EntityIdRef>;
    // (undocumented)
    createRecordDependency(newRecordData: NewRecordData, events?: MutationEvent_2[]): Promise<NewRecordData>;
    // (undocumented)
    database: Database;
    // (undocumented)
    deleteDifferentTableReliance(recordName: string, records: EntityIdRef[], events?: MutationEvent_2[]): Promise<void>;
    // (undocumented)
    deleteNotReliantSeparateLinkRecords(recordName: string, record: EntityIdRef[], events?: MutationEvent_2[]): Promise<void>;
    // (undocumented)
    deleteRecord(recordName: string, matchExp: MatchExpressionData, events?: MutationEvent_2[], inSameRowDataOp?: boolean): Promise<Record_2[]>;
    // (undocumented)
    deleteRecordSameRowData(recordName: string, records: EntityIdRef[], events?: MutationEvent_2[], inSameRowDataOp?: boolean): Promise<void>;
    // (undocumented)
    findPath(recordName: string, attributePathStr: string, startRecordId: string, endRecordId: string, limitLength?: number): Promise<Record_2[] | undefined>;
    // Warning: (ae-forgotten-export) The symbol "RecordQueryRef" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    findRecords(entityQuery: RecordQuery, queryName?: string, recordQueryRef?: RecordQueryRef, context?: RecursiveContext): Promise<Record_2[]>;
    // (undocumented)
    findXToManyRelatedRecords(recordName: string, attributeName: string, recordId: string, relatedRecordQuery: RecordQuery, recordQueryRef: RecordQueryRef, context: RecursiveContext): Promise<Record_2[]>;
    // (undocumented)
    flashOutCombinedRecordsAndMergedLinks(newEntityData: NewRecordData, events?: MutationEvent_2[], reason?: string): Promise<{
        [k: string]: RawEntityData;
    }>;
    // (undocumented)
    getJoinTables(queryTree: RecordQueryTree, context?: string[], parentInfos?: [string, string, string]): JoinTables;
    // (undocumented)
    getPlaceholder: () => PlaceholderGen;
    // (undocumented)
    handleCreationReliance(newEntityData: NewRecordData, events?: MutationEvent_2[]): Promise<object>;
    // (undocumented)
    handleDeletedRecordReliance(recordName: string, record: EntityIdRef, events?: MutationEvent_2[]): Promise<EntityIdRef>;
    // (undocumented)
    handleUpdateReliance(entityName: string, matchedEntity: EntityIdRef, newEntityData: NewRecordData, events?: MutationEvent_2[]): Promise<Record_2>;
    // (undocumented)
    insertSameRowData(newEntityData: NewRecordData, queryName?: string, events?: MutationEvent_2[]): Promise<EntityIdRef>;
    // (undocumented)
    map: EntityToTableMap;
    // (undocumented)
    parseMatchExpressionValue(entityName: string, fieldMatchExp: BoolExp<FieldMatchAtom> | null, contextRootEntity: string | undefined, p: PlaceholderGen): BoolExp<FieldMatchAtom> | null;
    // (undocumented)
    prepareFieldValue(value: any): any;
    // (undocumented)
    preprocessSameRowData(newEntityData: NewRecordData, isUpdate?: boolean, events?: MutationEvent_2[], oldRecord?: Record_2): Promise<NewRecordData>;
    // (undocumented)
    relocateCombinedRecordDataForLink(linkName: string, matchExpressionData: MatchExpressionData, moveSource?: boolean, events?: MutationEvent_2[]): Promise<void>;
    // (undocumented)
    structureRawReturns(rawReturns: {
        [k: string]: any;
    }[], JSONFields: string[]): {}[];
    // (undocumented)
    unlink(linkName: string, matchExpressionData: MatchExpressionData, moveSource?: boolean, reason?: string, events?: MutationEvent_2[]): Promise<void | Record_2[]>;
    // (undocumented)
    updateRecord(entityName: string, matchExpressionData: MatchExpressionData, newEntityData: NewRecordData, events?: MutationEvent_2[]): Promise<Record_2[]>;
    // (undocumented)
    updateRecordDataById(entityName: string, idRef: EntityIdRef, columnAndValue: {
        field: string;
        value: string;
    }[]): Promise<EntityIdRef>;
    // (undocumented)
    updateSameRowData(entityName: string, matchedEntity: Record_2, newEntityDataWithDep: NewRecordData, events?: MutationEvent_2[]): Promise<NewRecordData>;
    // (undocumented)
    withPrefix(prefix?: string): string;
}

// @public (undocumented)
export type RecordQueryData = {
    matchExpression?: MatchExpressionData;
    attributeQuery?: AttributeQueryData;
    modifier?: ModifierData;
    label?: string;
    goto?: string;
    exit?: (data: RecursiveContext) => Promise<any>;
};

// @public (undocumented)
export class RecordQueryTree {
    constructor(recordName: string, map: EntityToTableMap, parentRecord?: string | undefined, attributeName?: string | undefined, data?: {
        fields: string[];
        records: {
            [k: string]: RecordQueryTree;
        };
    } | undefined, parent?: RecordQueryTree | undefined, parentLinkQueryTree?: RecordQueryTree | undefined);
    // (undocumented)
    addField(namePath: string[]): void;
    // (undocumented)
    addRecord(namePath: string[], subTree?: RecordQueryTree): void;
    // (undocumented)
    attributeName?: string | undefined;
    // (undocumented)
    data?: {
        fields: string[];
        records: {
            [k: string]: RecordQueryTree;
        };
    } | undefined;
    // (undocumented)
    fields: string[];
    // (undocumented)
    forEachRecords(handle: (t: RecordQueryTree) => any): void;
    // (undocumented)
    getData(): {
        [k: string]: any;
    };
    // (undocumented)
    info?: AttributeInfo;
    // (undocumented)
    map: EntityToTableMap;
    // (undocumented)
    merge(otherTree: RecordQueryTree): RecordQueryTree;
    // (undocumented)
    onlyIdField(): boolean;
    // (undocumented)
    parent?: RecordQueryTree | undefined;
    // (undocumented)
    parentLinkQueryTree?: RecordQueryTree | undefined;
    // (undocumented)
    parentRecord?: string | undefined;
    // (undocumented)
    recordName: string;
    // (undocumented)
    records: {
        [k: string]: RecordQueryTree;
    };
}

// @public (undocumented)
export class RecursiveContext {
    constructor(label: string, parent?: RecursiveContext | undefined, stack?: any[]);
    // (undocumented)
    concat(value: any): RecursiveContext;
    // (undocumented)
    getStack(key: string): any[];
    // (undocumented)
    label: string;
    // (undocumented)
    parent?: RecursiveContext | undefined;
    // (undocumented)
    spawn(label: string): RecursiveContext;
    // (undocumented)
    stack: any[];
}

// @public (undocumented)
export const ROOT_LABEL = ":root";

// @public (undocumented)
export const ROW_ID_ATTR = "_rowId";

// @public (undocumented)
export function someAsync<T>(arr: T[], handle: (t: T) => Promise<boolean>): Promise<boolean>;

// @public (undocumented)
export type TableData = {
    [k: string]: {
        columns: {
            [k: string]: ColumnData;
        };
        hasId?: boolean;
    };
};

// @public (undocumented)
export type ValueAttribute = {
    type: string;
    collection?: boolean;
    table?: string;
    field: string;
    fieldType?: string;
    computed?: (record: any) => any;
    defaultValue?: () => any;
};

// Warnings were encountered during analysis:
//
// erstorage/EntityToTableMap.ts:79:5 - (ae-forgotten-export) The symbol "RecordMap" needs to be exported by the entry point index.d.ts
// erstorage/EntityToTableMap.ts:80:5 - (ae-forgotten-export) The symbol "LinkMap" needs to be exported by the entry point index.d.ts
// erstorage/Setup.ts:21:19 - (ae-forgotten-export) The symbol "ColumnData" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
