## API Report File for "@interaqt/runtime"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AsyncLocalStorage } from 'async_hooks';
import { Atom } from 'data0';
import { ClientConfig } from 'pg';
import { Connection } from 'mysql2/promise';
import { ConnectionOptions } from 'mysql2/promise';
import cors from 'cors';
import { FastifyLoggerOptions } from 'fastify';
import { MatchExpressionData } from '@interaqt/storage';
import { MutationEvent } from '@interaqt/storage';
import mysql from 'mysql2/promise';
import pg from 'pg';
import SQLite from 'better-sqlite3';
import { UnwrapReactive } from 'data0';

// @public (undocumented)
export const Action: Klass<{
    name: {
        type: "string";
        required: true;
    };
}>;

// Warning: (ae-forgotten-export) The symbol "ActivityPublicType" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const Activity: Klass<ActivityPublicType>;

// @public (undocumented)
export const ACTIVITY_RECORD = "_Activity_";

// @public (undocumented)
export const activityEntity: InertKlassInstance<    {
    name: {
        type: "string";
        collection: false;
        required: true;
        constraints: {
            nameFormat({ name }: {
                name: Atom<string>;
            }): Atom<boolean>;
        };
    };
    computedData: {
        type: Klass<any>[];
        collection: false;
        required: false;
    };
    properties: {
        type: Klass<    {
            name: {
                type: "string";
                required: true;
                collection: false;
                constraints: {
                    format({ name }: {
                        name: Atom<string>;
                    }): Atom<boolean>;
                    length({ name }: {
                        name: Atom<string>;
                    }): Atom<boolean>;
                };
            };
            type: {
                type: "string";
                required: true;
                collection: false;
                options: PropertyTypes[];
            };
            collection: {
                type: "boolean";
                required: true;
                collection: false;
                defaultValue(): boolean;
            };
            args: {
                computedType: (values: {
                    type: PropertyTypes;
                }) => string;
            };
            computedData: {
                collection: false;
                type: Klass<any>[];
                required: false;
            };
            computed: {
                required: false;
                type: "function";
                collection: false;
            };
        }>;
        collection: true;
        required: true;
        constraints: {
            eachNameUnique({ properties }: any): Atom<boolean>;
        };
        defaultValue(): never[];
    };
    isRef: {
        required: true;
        collection: false;
        type: "boolean";
        defaultValue: () => boolean;
    };
}>;

// @public (undocumented)
export const ActivityGroup: Klass<ActivityGroupPublicType>;

// @public (undocumented)
export type ActivityGroupInstanceType = KlassInstance<Klass<ActivityGroupPublicType>, false>;

// @public (undocumented)
export type ActivityGroupPublicType = {
    type: {
        type: 'string';
        required: true;
        collection: false;
    };
    activities: {
        instanceType: UnwrappedActivityInstanceType;
        required: false;
        collection: true;
        defaultValue: (...args: any[]) => UnwrappedActivityInstanceType[];
    };
};

// @public (undocumented)
export type ActivityInstanceType = KlassInstance<typeof Activity, false>;

// @public (undocumented)
export const Any: Klass<    {
    record: {
        type: (Klass<    {
            name: {
                type: "string";
                collection: false;
                required: true;
                constraints: {
                    nameFormat({ name }: {
                        name: Atom<string>;
                    }): Atom<boolean>;
                };
            };
            computedData: {
                type: Klass<any>[];
                collection: false;
                required: false;
            };
            properties: {
                type: Klass<    {
                    name: {
                        type: "string";
                        required: true;
                        collection: false;
                        constraints: {
                            format({ name }: {
                                name: Atom<string>;
                            }): Atom<boolean>;
                            length({ name }: {
                                name: Atom<string>;
                            }): Atom<boolean>;
                        };
                    };
                    type: {
                        type: "string";
                        required: true;
                        collection: false;
                        options: PropertyTypes[];
                    };
                    collection: {
                        type: "boolean";
                        required: true;
                        collection: false;
                        defaultValue(): boolean;
                    };
                    args: {
                        computedType: (values: {
                            type: PropertyTypes;
                        }) => string;
                    };
                    computedData: {
                        collection: false;
                        type: Klass<any>[];
                        required: false;
                    };
                    computed: {
                        required: false;
                        type: "function";
                        collection: false;
                    };
                }>;
                collection: true;
                required: true;
                constraints: {
                    eachNameUnique({ properties }: any): Atom<boolean>;
                };
                defaultValue(): never[];
            };
            isRef: {
                required: true;
                collection: false;
                type: "boolean";
                defaultValue: () => boolean;
            };
        }> | Klass<RelationPublic>)[];
        collection: false;
        required: true;
    };
    match: {
        type: "function";
        collection: false;
        required: true;
    };
}>;

// @public (undocumented)
export type APIBody = {
    activity?: string;
    interaction?: string;
    activityId?: string;
    payload?: EventPayload;
    query?: EventQuery;
};

// @public (undocumented)
export function assert(condition: any, message: string): void;

// @public (undocumented)
export const asyncInteractionContext: AsyncLocalStorage<unknown>;

// @public (undocumented)
export type AtomHandle<T> = (arg: T) => boolean | Promise<boolean>;

// @public (undocumented)
export const Attributive: Klass<    {
    stringContent: {
        type: "string";
    };
    content: {
        type: "function";
        required: true;
        collection: false;
    };
    name: {
        type: "string";
    };
    isRef: {
        type: "boolean";
    };
}>;

// @public (undocumented)
export const Attributives: Klass<    {
    content: {
        type: (Klass<    {
            type: {
                type: "string";
                required: true;
                collection: false;
                defaultValue: () => string;
            };
            data: {
                instanceType: ReactiveKlassInstance<    {
                    content: {
                        type: "function";
                        required: true;
                        collection: false;
                    };
                }> | InertKlassInstance<    {
                    content: {
                        type: "function";
                        required: true;
                        collection: false;
                    };
                }>;
                required: true;
                collection: false;
            };
        }> | Klass<    {
            type: {
                type: "string";
                required: true;
                collection: false;
                defaultValue: () => string;
            };
            operator: {
                type: "string";
                required: true;
                collection: false;
                options: string[];
                defaultValue: () => string;
            };
            left: {
                instanceType: InertKlassInstance<    {
                    type: {
                        type: "string";
                        required: true;
                        collection: false;
                        defaultValue: () => string;
                    };
                    data: {
                        instanceType: ReactiveKlassInstance<    {
                            content: {
                                type: "function";
                                required: true;
                                collection: false;
                            };
                        }> | InertKlassInstance<    {
                            content: {
                                type: "function";
                                required: true;
                                collection: false;
                            };
                        }>;
                        required: true;
                        collection: false;
                    };
                }> | UnwrappedBoolExpressionInstanceType<any>;
                required: true;
                collection: false;
            };
            right: {
                instanceType: InertKlassInstance<    {
                    type: {
                        type: "string";
                        required: true;
                        collection: false;
                        defaultValue: () => string;
                    };
                    data: {
                        instanceType: ReactiveKlassInstance<    {
                            content: {
                                type: "function";
                                required: true;
                                collection: false;
                            };
                        }> | InertKlassInstance<    {
                            content: {
                                type: "function";
                                required: true;
                                collection: false;
                            };
                        }>;
                        required: true;
                        collection: false;
                    };
                }> | UnwrappedBoolExpressionInstanceType<any>;
                required: false;
                collection: false;
            };
        }>)[];
        collection: false;
        required: false;
    };
}>;

// @public (undocumented)
export const BoolAtomData: Klass<{
    type: {
        type: "string";
        required: true;
        collection: false;
        defaultValue: () => string;
    };
    data: {
        instanceType: ReactiveKlassInstance<CommonAtomPublic> | InertKlassInstance<CommonAtomPublic>;
        required: true;
        collection: false;
    };
}>;

// @public (undocumented)
export class BoolExp<T> {
    constructor(raw: ExpressionData<T>);
    // (undocumented)
    static and<U>(...atomValues: U[]): BoolExp<U>;
    // (undocumented)
    and(atomValueOrExp: any): BoolExp<T>;
    // (undocumented)
    static atom<U>(data: U): BoolExp<U>;
    // (undocumented)
    get data(): T;
    // (undocumented)
    evaluate(atomHandle: AtomHandle<T>, stack?: any[], inverse?: boolean): true | EvaluateError;
    // (undocumented)
    evaluateAsync(atomHandle: AtomHandle<T>, stack?: any[], inverse?: boolean): Promise<true | EvaluateError>;
    // (undocumented)
    find(matchFn: (atom: T, context: string[]) => boolean, context: any[]): T | undefined;
    // (undocumented)
    static fromValue<T>(value: ExpressionData<T>): BoolExp<T>;
    // (undocumented)
    isAnd(): boolean;
    // (undocumented)
    isAtom(): boolean;
    // (undocumented)
    isExpression(): boolean;
    // (undocumented)
    isNot(): boolean;
    // (undocumented)
    isOr(): boolean;
    // (undocumented)
    get left(): BoolExp<T>;
    // Warning: (ae-forgotten-export) The symbol "MapFn" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    map<U>(fn: MapFn<T, U>, context?: string[]): BoolExp<U>;
    // (undocumented)
    not(): BoolExp<T>;
    // (undocumented)
    static or<U>(...atomValues: U[]): BoolExp<U>;
    // (undocumented)
    or(atomValueOrExp: any): BoolExp<T>;
    // (undocumented)
    raw: ExpressionData<T>;
    // (undocumented)
    get right(): BoolExp<T> | undefined;
    // Warning: (ae-forgotten-export) The symbol "AtomData" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    toValue(): AtomData<T>;
}

// @public (undocumented)
export type BoolExpression = GroupNode | VariableNode;

// @public (undocumented)
export const BoolExpressionData: Klass<{
    type: {
        type: "string";
        required: true;
        collection: false;
        defaultValue: () => string;
    };
    operator: {
        type: "string";
        required: true;
        collection: false;
        options: string[];
        defaultValue: () => string;
    };
    left: {
        instanceType: InertKlassInstance<    {
            type: {
                type: "string";
                required: true;
                collection: false;
                defaultValue: () => string;
            };
            data: {
                instanceType: ReactiveKlassInstance<CommonAtomPublic> | InertKlassInstance<CommonAtomPublic>;
                required: true;
                collection: false;
            };
        }> | UnwrappedBoolExpressionInstanceType<any>;
        required: true;
        collection: false;
    };
    right: {
        instanceType: InertKlassInstance<    {
            type: {
                type: "string";
                required: true;
                collection: false;
                defaultValue: () => string;
            };
            data: {
                instanceType: ReactiveKlassInstance<CommonAtomPublic> | InertKlassInstance<CommonAtomPublic>;
                required: true;
                collection: false;
            };
        }> | UnwrappedBoolExpressionInstanceType<any>;
        required: false;
        collection: false;
    };
}>;

// @public (undocumented)
export const enum BoolExpressionNodeTypes {
    // (undocumented)
    group = "group",
    // (undocumented)
    variable = "variable"
}

// @public (undocumented)
export type BoolExpressionRawData<T> = {
    type: 'expression';
    operator: 'and' | 'not' | 'or';
    left: ExpressionData<T>;
    right?: ExpressionData<T>;
};

// @public (undocumented)
export function boolExpToAttributives(obj: BoolExp<KlassInstance<typeof Attributive, false>>): InertKlassInstance<    {
    content: {
        type: (Klass<    {
            type: {
                type: "string";
                required: true;
                collection: false;
                defaultValue: () => string;
            };
            data: {
                instanceType: ReactiveKlassInstance<    {
                    content: {
                        type: "function";
                        required: true;
                        collection: false;
                    };
                }> | InertKlassInstance<    {
                    content: {
                        type: "function";
                        required: true;
                        collection: false;
                    };
                }>;
                required: true;
                collection: false;
            };
        }> | Klass<    {
            type: {
                type: "string";
                required: true;
                collection: false;
                defaultValue: () => string;
            };
            operator: {
                type: "string";
                required: true;
                collection: false;
                options: string[];
                defaultValue: () => string;
            };
            left: {
                instanceType: InertKlassInstance<    {
                    type: {
                        type: "string";
                        required: true;
                        collection: false;
                        defaultValue: () => string;
                    };
                    data: {
                        instanceType: ReactiveKlassInstance<    {
                            content: {
                                type: "function";
                                required: true;
                                collection: false;
                            };
                        }> | InertKlassInstance<    {
                            content: {
                                type: "function";
                                required: true;
                                collection: false;
                            };
                        }>;
                        required: true;
                        collection: false;
                    };
                }> | UnwrappedBoolExpressionInstanceType<any>;
                required: true;
                collection: false;
            };
            right: {
                instanceType: InertKlassInstance<    {
                    type: {
                        type: "string";
                        required: true;
                        collection: false;
                        defaultValue: () => string;
                    };
                    data: {
                        instanceType: ReactiveKlassInstance<    {
                            content: {
                                type: "function";
                                required: true;
                                collection: false;
                            };
                        }> | InertKlassInstance<    {
                            content: {
                                type: "function";
                                required: true;
                                collection: false;
                            };
                        }>;
                        required: true;
                        collection: false;
                    };
                }> | UnwrappedBoolExpressionInstanceType<any>;
                required: false;
                collection: false;
            };
        }>)[];
        collection: false;
        required: false;
    };
}>;

// @public (undocumented)
export function boolExpToConditions(obj: BoolExp<KlassInstance<typeof Condition, false>>): InertKlassInstance<    {
    content: {
        type: (Klass<    {
            type: {
                type: "string";
                required: true;
                collection: false;
                defaultValue: () => string;
            };
            data: {
                instanceType: ReactiveKlassInstance<    {
                    content: {
                        type: "function";
                        required: true;
                        collection: false;
                    };
                }> | InertKlassInstance<    {
                    content: {
                        type: "function";
                        required: true;
                        collection: false;
                    };
                }>;
                required: true;
                collection: false;
            };
        }> | Klass<    {
            type: {
                type: "string";
                required: true;
                collection: false;
                defaultValue: () => string;
            };
            operator: {
                type: "string";
                required: true;
                collection: false;
                options: string[];
                defaultValue: () => string;
            };
            left: {
                instanceType: InertKlassInstance<    {
                    type: {
                        type: "string";
                        required: true;
                        collection: false;
                        defaultValue: () => string;
                    };
                    data: {
                        instanceType: ReactiveKlassInstance<    {
                            content: {
                                type: "function";
                                required: true;
                                collection: false;
                            };
                        }> | InertKlassInstance<    {
                            content: {
                                type: "function";
                                required: true;
                                collection: false;
                            };
                        }>;
                        required: true;
                        collection: false;
                    };
                }> | UnwrappedBoolExpressionInstanceType<any>;
                required: true;
                collection: false;
            };
            right: {
                instanceType: InertKlassInstance<    {
                    type: {
                        type: "string";
                        required: true;
                        collection: false;
                        defaultValue: () => string;
                    };
                    data: {
                        instanceType: ReactiveKlassInstance<    {
                            content: {
                                type: "function";
                                required: true;
                                collection: false;
                            };
                        }> | InertKlassInstance<    {
                            content: {
                                type: "function";
                                required: true;
                                collection: false;
                            };
                        }>;
                        required: true;
                        collection: false;
                    };
                }> | UnwrappedBoolExpressionInstanceType<any>;
                required: false;
                collection: false;
            };
        }>)[];
        collection: false;
        required: false;
    };
}>;

// @public (undocumented)
export function boolExpToDataAttributives(obj: BoolExp<KlassInstance<typeof DataAttributive, false>>): InertKlassInstance<    {
    content: {
        type: (Klass<    {
            type: {
                type: "string";
                required: true;
                collection: false;
                defaultValue: () => string;
            };
            data: {
                instanceType: ReactiveKlassInstance<    {
                    content: {
                        type: "function";
                        required: true;
                        collection: false;
                    };
                }> | InertKlassInstance<    {
                    content: {
                        type: "function";
                        required: true;
                        collection: false;
                    };
                }>;
                required: true;
                collection: false;
            };
        }> | Klass<    {
            type: {
                type: "string";
                required: true;
                collection: false;
                defaultValue: () => string;
            };
            operator: {
                type: "string";
                required: true;
                collection: false;
                options: string[];
                defaultValue: () => string;
            };
            left: {
                instanceType: InertKlassInstance<    {
                    type: {
                        type: "string";
                        required: true;
                        collection: false;
                        defaultValue: () => string;
                    };
                    data: {
                        instanceType: ReactiveKlassInstance<    {
                            content: {
                                type: "function";
                                required: true;
                                collection: false;
                            };
                        }> | InertKlassInstance<    {
                            content: {
                                type: "function";
                                required: true;
                                collection: false;
                            };
                        }>;
                        required: true;
                        collection: false;
                    };
                }> | UnwrappedBoolExpressionInstanceType<any>;
                required: true;
                collection: false;
            };
            right: {
                instanceType: InertKlassInstance<    {
                    type: {
                        type: "string";
                        required: true;
                        collection: false;
                        defaultValue: () => string;
                    };
                    data: {
                        instanceType: ReactiveKlassInstance<    {
                            content: {
                                type: "function";
                                required: true;
                                collection: false;
                            };
                        }> | InertKlassInstance<    {
                            content: {
                                type: "function";
                                required: true;
                                collection: false;
                            };
                        }>;
                        required: true;
                        collection: false;
                    };
                }> | UnwrappedBoolExpressionInstanceType<any>;
                required: false;
                collection: false;
            };
        }>)[];
        collection: false;
        required: false;
    };
}>;

// @public (undocumented)
export const Computation: Klass<    {
    content: {
        type: "function";
        required: true;
        collection: false;
    };
    name: {
        type: "string";
    };
}>;

// @public (undocumented)
export const ComputedData: Klass<    {
    computeEffect: {
        type: "string";
        collection: false;
        required: true;
    };
    computation: {
        type: "string";
        collection: false;
        required: true;
    };
}>;

// @public (undocumented)
export interface Concept {
    // (undocumented)
    name: string;
}

// @public (undocumented)
export interface ConceptAlias extends Concept {
    // (undocumented)
    for: Concept[];
}

// @public (undocumented)
export type ConceptInstance = any;

// @public (undocumented)
export type ConceptType = {};

// @public (undocumented)
export const Condition: Klass<    {
    content: {
        type: "function";
        required: true;
        collection: false;
    };
    name: {
        type: "string";
    };
}>;

// @public (undocumented)
export const Conditions: Klass<    {
    content: {
        type: (Klass<    {
            type: {
                type: "string";
                required: true;
                collection: false;
                defaultValue: () => string;
            };
            data: {
                instanceType: ReactiveKlassInstance<    {
                    content: {
                        type: "function";
                        required: true;
                        collection: false;
                    };
                }> | InertKlassInstance<    {
                    content: {
                        type: "function";
                        required: true;
                        collection: false;
                    };
                }>;
                required: true;
                collection: false;
            };
        }> | Klass<    {
            type: {
                type: "string";
                required: true;
                collection: false;
                defaultValue: () => string;
            };
            operator: {
                type: "string";
                required: true;
                collection: false;
                options: string[];
                defaultValue: () => string;
            };
            left: {
                instanceType: InertKlassInstance<    {
                    type: {
                        type: "string";
                        required: true;
                        collection: false;
                        defaultValue: () => string;
                    };
                    data: {
                        instanceType: ReactiveKlassInstance<    {
                            content: {
                                type: "function";
                                required: true;
                                collection: false;
                            };
                        }> | InertKlassInstance<    {
                            content: {
                                type: "function";
                                required: true;
                                collection: false;
                            };
                        }>;
                        required: true;
                        collection: false;
                    };
                }> | UnwrappedBoolExpressionInstanceType<any>;
                required: true;
                collection: false;
            };
            right: {
                instanceType: InertKlassInstance<    {
                    type: {
                        type: "string";
                        required: true;
                        collection: false;
                        defaultValue: () => string;
                    };
                    data: {
                        instanceType: ReactiveKlassInstance<    {
                            content: {
                                type: "function";
                                required: true;
                                collection: false;
                            };
                        }> | InertKlassInstance<    {
                            content: {
                                type: "function";
                                required: true;
                                collection: false;
                            };
                        }>;
                        required: true;
                        collection: false;
                    };
                }> | UnwrappedBoolExpressionInstanceType<any>;
                required: false;
                collection: false;
            };
        }>)[];
        collection: false;
        required: false;
    };
}>;

// @public (undocumented)
export const constraints: {
    entityNameUnique({ entities }: {
        entities: (typeof Entity)[];
    }): Atom<boolean>;
};

// @public (undocumented)
export class Controller {
    constructor(system: System, entities: KlassInstance<typeof Entity, false>[], relations: KlassInstance<typeof Relation, false>[], activities: KlassInstance<typeof Activity, false>[], interactions: KlassInstance<typeof Interaction, false>[], states?: KlassInstance<typeof Property, false>[], recordMutationSideEffects?: KlassInstance<typeof RecordMutationSideEffect, false>[]);
    // (undocumented)
    activities: KlassInstance<typeof Activity, false>[];
    // Warning: (ae-forgotten-export) The symbol "ActivityCall" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    activityCalls: Map<string, ActivityCall>;
    // (undocumented)
    activityCallsByName: Map<string, ActivityCall>;
    // Warning: (ae-forgotten-export) The symbol "DataContext" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    addComputedDataHandle(computedData: KlassInstance<any, false>, host: DataContext["host"], id: DataContext["id"]): void;
    // (undocumented)
    callActivityInteraction(activityCallId: string, interactionCallId: string, activityId: string | undefined, interactionEventArgs: InteractionEventArgs): Promise<InteractionCallResponse>;
    // (undocumented)
    callbacks: Map<any, Set<SystemCallback>>;
    // Warning: (ae-forgotten-export) The symbol "InteractionCallResponse" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    callInteraction(interactionId: string, interactionEventArgs: InteractionEventArgs): Promise<InteractionCallResponse>;
    // Warning: (ae-forgotten-export) The symbol "ComputedDataHandle" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    computedDataHandles: Set<ComputedDataHandle>;
    // (undocumented)
    entities: KlassInstance<typeof Entity, false>[];
    // (undocumented)
    globals: {
        BoolExp: typeof BoolExp;
    };
    // (undocumented)
    interactionCalls: Map<string, InteractionCall>;
    // Warning: (ae-forgotten-export) The symbol "InteractionCall" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    interactionCallsByName: Map<string, InteractionCall>;
    // (undocumented)
    interactions: KlassInstance<typeof Interaction, false>[];
    // (undocumented)
    recordMutationSideEffects: KlassInstance<typeof RecordMutationSideEffect, false>[];
    // (undocumented)
    recordNameToSideEffects: Map<string, Set<InertKlassInstance<    {
        name: {
            type: "string";
            collection: false;
            required: true;
        };
        record: {
            type: (Klass<{
                name: {
                    type: "string";
                    collection: false;
                    required: true;
                    constraints: {
                        nameFormat({ name }: {
                            name: Atom<string>;
                        }): Atom<boolean>;
                    };
                };
                computedData: {
                    type: Klass<any>[];
                    collection: false;
                    required: false;
                };
                properties: {
                    type: Klass<{
                        name: {
                            type: "string";
                            required: true;
                            collection: false;
                            constraints: {
                                format({ name }: {
                                    name: Atom<string>;
                                }): Atom<boolean>;
                                length({ name }: {
                                    name: Atom<string>;
                                }): Atom<boolean>;
                            };
                        };
                        type: {
                            type: "string";
                            required: true;
                            collection: false;
                            options: PropertyTypes[];
                        };
                        collection: {
                            type: "boolean";
                            required: true;
                            collection: false;
                            defaultValue(): boolean;
                        };
                        args: {
                            computedType: (values: {
                                type: PropertyTypes;
                            }) => string;
                        };
                        computedData: {
                            collection: false;
                            type: Klass<any>[];
                            required: false;
                        };
                        computed: {
                            required: false;
                            type: "function";
                            collection: false;
                        };
                    }>;
                    collection: true;
                    required: true;
                    constraints: {
                        eachNameUnique({ properties }: any): Atom<boolean>;
                    };
                    defaultValue(): never[];
                };
                isRef: {
                    required: true;
                    collection: false;
                    type: "boolean";
                    defaultValue: () => boolean;
                };
            }> | Klass<RelationPublic>)[];
            collection: false;
            required: true;
        };
        content: {
            type: "function";
            collection: false;
            required: true;
        };
    }>>>;
    // (undocumented)
    relations: KlassInstance<typeof Relation, false>[];
    // (undocumented)
    runRecordChangeSideEffects(result: InteractionCallResponse, logger: SystemLogger): Promise<void>;
    // (undocumented)
    setup(install?: boolean): Promise<void>;
    // (undocumented)
    states: KlassInstance<typeof Property, false>[];
    // (undocumented)
    system: System;
}

// @public (undocumented)
export const Count: Klass<    {
    record: {
        type: (Klass<    {
            name: {
                type: "string";
                collection: false;
                required: true;
                constraints: {
                    nameFormat({ name }: {
                        name: Atom<string>;
                    }): Atom<boolean>;
                };
            };
            computedData: {
                type: Klass<any>[];
                collection: false;
                required: false;
            };
            properties: {
                type: Klass<    {
                    name: {
                        type: "string";
                        required: true;
                        collection: false;
                        constraints: {
                            format({ name }: {
                                name: Atom<string>;
                            }): Atom<boolean>;
                            length({ name }: {
                                name: Atom<string>;
                            }): Atom<boolean>;
                        };
                    };
                    type: {
                        type: "string";
                        required: true;
                        collection: false;
                        options: PropertyTypes[];
                    };
                    collection: {
                        type: "boolean";
                        required: true;
                        collection: false;
                        defaultValue(): boolean;
                    };
                    args: {
                        computedType: (values: {
                            type: PropertyTypes;
                        }) => string;
                    };
                    computedData: {
                        collection: false;
                        type: Klass<any>[];
                        required: false;
                    };
                    computed: {
                        required: false;
                        type: "function";
                        collection: false;
                    };
                }>;
                collection: true;
                required: true;
                constraints: {
                    eachNameUnique({ properties }: any): Atom<boolean>;
                };
                defaultValue(): never[];
            };
            isRef: {
                required: true;
                collection: false;
                type: "boolean";
                defaultValue: () => boolean;
            };
        }> | Klass<RelationPublic>)[];
        collection: false;
        required: true;
    };
    match: {
        type: "function";
        collection: false;
        required: true;
    };
}>;

// @public (undocumented)
export function createClass<T extends KlassMeta>(metadata: T): Klass<T['public']>;

// @public (undocumented)
export function createDataAPI(handle: DataAPIHandle, config?: DataAPIConfig): DataAPI;

// Warning: (ae-forgotten-export) The symbol "KlassRawInstanceDataType" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function createInstances(objects: KlassRawInstanceDataType[], reactiveForce?: boolean): Map<string, InertKlassInstance<any> | ReactiveKlassInstance<any>>;

// @public (undocumented)
export function createInstancesFromString(objStr: string): Map<string, InertKlassInstance<any> | ReactiveKlassInstance<any>>;

// @public (undocumented)
export function createUserRoleAttributive({ name, isRef }: {
    name?: string;
    isRef?: boolean;
}, options?: KlassOptions | ReactiveKlassOptions): InertKlassInstance<    {
    stringContent: {
        type: "string";
    };
    content: {
        type: "function";
        required: true;
        collection: false;
    };
    name: {
        type: "string";
    };
    isRef: {
        type: "boolean";
    };
}> | ReactiveKlassInstance<    {
    stringContent: {
        type: "string";
    };
    content: {
        type: "function";
        required: true;
        collection: false;
    };
    name: {
        type: "string";
    };
    isRef: {
        type: "boolean";
    };
}>;

// @public (undocumented)
export type DataAPI = DataAPIHandle & DataAPIConfig;

// @public (undocumented)
export type DataAPIConfig = {
    params?: any[] | {};
    useNamedParams?: boolean;
    allowAnonymous?: boolean;
};

// @public (undocumented)
export type DataAPIContext = {
    user: EventUser;
};

// @public (undocumented)
export type DataAPIHandle = (this: Controller, context: DataAPIContext, ...rest: any[]) => any;

// @public (undocumented)
export type DataAPIs = {
    [k: string]: DataAPI;
};

// @public (undocumented)
export const DataAttributive: Klass<    {
    content: {
        type: "function";
        required: true;
        collection: false;
    };
    name: {
        type: "string";
    };
}>;

// @public (undocumented)
export const DataAttributives: Klass<    {
    content: {
        type: (Klass<    {
            type: {
                type: "string";
                required: true;
                collection: false;
                defaultValue: () => string;
            };
            data: {
                instanceType: ReactiveKlassInstance<    {
                    content: {
                        type: "function";
                        required: true;
                        collection: false;
                    };
                }> | InertKlassInstance<    {
                    content: {
                        type: "function";
                        required: true;
                        collection: false;
                    };
                }>;
                required: true;
                collection: false;
            };
        }> | Klass<    {
            type: {
                type: "string";
                required: true;
                collection: false;
                defaultValue: () => string;
            };
            operator: {
                type: "string";
                required: true;
                collection: false;
                options: string[];
                defaultValue: () => string;
            };
            left: {
                instanceType: InertKlassInstance<    {
                    type: {
                        type: "string";
                        required: true;
                        collection: false;
                        defaultValue: () => string;
                    };
                    data: {
                        instanceType: ReactiveKlassInstance<    {
                            content: {
                                type: "function";
                                required: true;
                                collection: false;
                            };
                        }> | InertKlassInstance<    {
                            content: {
                                type: "function";
                                required: true;
                                collection: false;
                            };
                        }>;
                        required: true;
                        collection: false;
                    };
                }> | UnwrappedBoolExpressionInstanceType<any>;
                required: true;
                collection: false;
            };
            right: {
                instanceType: InertKlassInstance<    {
                    type: {
                        type: "string";
                        required: true;
                        collection: false;
                        defaultValue: () => string;
                    };
                    data: {
                        instanceType: ReactiveKlassInstance<    {
                            content: {
                                type: "function";
                                required: true;
                                collection: false;
                            };
                        }> | InertKlassInstance<    {
                            content: {
                                type: "function";
                                required: true;
                                collection: false;
                            };
                        }>;
                        required: true;
                        collection: false;
                    };
                }> | UnwrappedBoolExpressionInstanceType<any>;
                required: false;
                collection: false;
            };
        }>)[];
        collection: false;
        required: false;
    };
}>;

// @public (undocumented)
export type Database = {
    open: () => Promise<any>;
    logger: DatabaseLogger;
    scheme: (sql: string, name?: string) => Promise<any>;
    query: <T extends any>(sql: string, values: any[], name?: string) => Promise<T[]>;
    delete: <T extends any>(sql: string, where: any[], name?: string) => Promise<T[]>;
    insert: (sql: string, values: any[], name?: string) => Promise<EntityIdRef>;
    update: (sql: string, values: any[], idField?: string, name?: string) => Promise<EntityIdRef[]>;
    getAutoId: (recordName: string) => Promise<string>;
    parseMatchExpression?: (key: string, value: [string, any], fieldName: string, fieldType: string, isReferenceValue: boolean, getReferenceFieldValue: (v: string) => string, genPlaceholder: (name?: string) => string) => any;
    getPlaceholder?: () => (name?: string) => string;
    mapToDBFieldType: (type: string, collection?: boolean) => string;
};

// @public (undocumented)
export type DatabaseLogger = {
    info: (arg: {
        type: string;
        name: string;
        sql: string;
        params?: any[];
    }) => any;
    child: (fixed: object) => DatabaseLogger;
};

// @public (undocumented)
export function deepClone<T>(obj: T, deepCloneKlass?: boolean): T;

// @public (undocumented)
export interface DerivedConcept extends Concept {
    // (undocumented)
    attributive?: any;
    // (undocumented)
    base?: Concept;
}

// @public (undocumented)
export const Entity: Klass<{
    name: {
        type: "string";
        collection: false;
        required: true;
        constraints: {
            nameFormat({ name }: {
                name: Atom<string>;
            }): Atom<boolean>;
        };
    };
    computedData: {
        type: Klass<any>[];
        collection: false;
        required: false;
    };
    properties: {
        type: Klass<{
            name: {
                type: "string";
                required: true;
                collection: false;
                constraints: {
                    format({ name }: {
                        name: Atom<string>;
                    }): Atom<boolean>;
                    length({ name }: {
                        name: Atom<string>;
                    }): Atom<boolean>;
                };
            };
            type: {
                type: "string";
                required: true;
                collection: false;
                options: PropertyTypes[];
            };
            collection: {
                type: "boolean";
                required: true;
                collection: false;
                defaultValue(): boolean;
            };
            args: {
                computedType: (values: {
                    type: PropertyTypes;
                }) => string;
            };
            computedData: {
                collection: false;
                type: Klass<any>[];
                required: false;
            };
            computed: {
                required: false;
                type: "function";
                collection: false;
            };
        }>;
        collection: true;
        required: true;
        constraints: {
            eachNameUnique({ properties }: any): Atom<boolean>;
        };
        defaultValue(): never[];
    };
    isRef: {
        required: true;
        collection: false;
        type: "boolean";
        defaultValue: () => boolean;
    };
}>;

// @public (undocumented)
export type EntityIdRef = {
    id: string;
    [ROW_ID_ATTR]?: string;
    [k: string]: any;
};

// Warning: (ae-forgotten-export) The symbol "EntityType" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "InferType" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type EntityInstanceType<T extends EntityType> = {
    [P in T['properties'][number] as P['name']]: P['collection'] extends true ? Array<InferType<P>> : InferType<P>;
};

// @public (undocumented)
export type EvaluateError = {
    data: any;
    stack: any[];
    error: any;
    inverse: boolean;
};

// @public (undocumented)
const Event_2: Klass<{
    name: {
        type: "string";
        required: true;
    };
}>;
export { Event_2 as Event }

// @public (undocumented)
export const EVENT_RECORD = "_Event_";

// @public (undocumented)
export const eventEntity: InertKlassInstance<    {
    name: {
        type: "string";
        collection: false;
        required: true;
        constraints: {
            nameFormat({ name }: {
                name: Atom<string>;
            }): Atom<boolean>;
        };
    };
    computedData: {
        type: Klass<any>[];
        collection: false;
        required: false;
    };
    properties: {
        type: Klass<    {
            name: {
                type: "string";
                required: true;
                collection: false;
                constraints: {
                    format({ name }: {
                        name: Atom<string>;
                    }): Atom<boolean>;
                    length({ name }: {
                        name: Atom<string>;
                    }): Atom<boolean>;
                };
            };
            type: {
                type: "string";
                required: true;
                collection: false;
                options: PropertyTypes[];
            };
            collection: {
                type: "boolean";
                required: true;
                collection: false;
                defaultValue(): boolean;
            };
            args: {
                computedType: (values: {
                    type: PropertyTypes;
                }) => string;
            };
            computedData: {
                collection: false;
                type: Klass<any>[];
                required: false;
            };
            computed: {
                required: false;
                type: "function";
                collection: false;
            };
        }>;
        collection: true;
        required: true;
        constraints: {
            eachNameUnique({ properties }: any): Atom<boolean>;
        };
        defaultValue(): never[];
    };
    isRef: {
        required: true;
        collection: false;
        type: "boolean";
        defaultValue: () => boolean;
    };
}>;

// @public (undocumented)
export type EventPayload = {
    [k: string]: any;
};

// @public
export type EventQuery = {
    [k: string]: any;
};

// @public (undocumented)
export type EventUser = {
    [k: string]: any;
    id: string;
};

// @public (undocumented)
export const Every: Klass<    {
    record: {
        type: (Klass<    {
            name: {
                type: "string";
                collection: false;
                required: true;
                constraints: {
                    nameFormat({ name }: {
                        name: Atom<string>;
                    }): Atom<boolean>;
                };
            };
            computedData: {
                type: Klass<any>[];
                collection: false;
                required: false;
            };
            properties: {
                type: Klass<    {
                    name: {
                        type: "string";
                        required: true;
                        collection: false;
                        constraints: {
                            format({ name }: {
                                name: Atom<string>;
                            }): Atom<boolean>;
                            length({ name }: {
                                name: Atom<string>;
                            }): Atom<boolean>;
                        };
                    };
                    type: {
                        type: "string";
                        required: true;
                        collection: false;
                        options: PropertyTypes[];
                    };
                    collection: {
                        type: "boolean";
                        required: true;
                        collection: false;
                        defaultValue(): boolean;
                    };
                    args: {
                        computedType: (values: {
                            type: PropertyTypes;
                        }) => string;
                    };
                    computedData: {
                        collection: false;
                        type: Klass<any>[];
                        required: false;
                    };
                    computed: {
                        required: false;
                        type: "function";
                        collection: false;
                    };
                }>;
                collection: true;
                required: true;
                constraints: {
                    eachNameUnique({ properties }: any): Atom<boolean>;
                };
                defaultValue(): never[];
            };
            isRef: {
                required: true;
                collection: false;
                type: "boolean";
                defaultValue: () => boolean;
            };
        }> | Klass<RelationPublic>)[];
        collection: false;
        required: true;
    };
    match: {
        type: "function";
        collection: false;
        required: true;
    };
    notEmpty: {
        type: "boolean";
        collection: false;
        required: false;
    };
}>;

// @public (undocumented)
export function everyAsync<T>(items: T[], check: (arg: T) => Promise<boolean>): Promise<boolean>;

// @public (undocumented)
export function everyWithErrorAsync<T, U>(items: T[], check: (arg: T) => Promise<true | U>): Promise<true | U>;

// @public (undocumented)
export type ExpressionData<T> = BoolExpressionRawData<T> | AtomData<T>;

// @public (undocumented)
export function filterMap(map: Map<any, any>, handle: (key: any, value: any) => boolean): Map<any, boolean>;

// @public (undocumented)
export function findRootActivity(interaction: InteractionInstanceType): ActivityInstanceType | null;

// @public (undocumented)
export function forEachInteraction(activity: ActivityInstanceType, handle: (i: InteractionInstanceType, g?: ActivityGroupInstanceType) => any, parenGroup?: ActivityGroupInstanceType): void;

// @public (undocumented)
export const Gateway: Klass<GatewayPublicType>;

// @public (undocumented)
export type GatewayInstanceType = KlassInstance<typeof Gateway, false>;

// @public (undocumented)
export type GatewayPublicType = {
    name: {
        type: 'string';
        required: true;
    };
};

// @public (undocumented)
export const GetAction: InertKlassInstance<    {
    name: {
        type: "string";
        required: true;
    };
}> | ReactiveKlassInstance<    {
    name: {
        type: "string";
        required: true;
    };
}>;

// @public (undocumented)
export function getDisplayValue(obj: InertKlassInstance<any>): string | undefined;

// @public (undocumented)
export function getInstance<T extends Klass<any>>(Type: T): KlassInstance<T, any>[];

// @public (undocumented)
export function getInteractions(activity: ActivityInstanceType): InertKlassInstance<InteractionPublicType>[];

// @public (undocumented)
export function getUUID(obj: InertKlassInstance<any>): string;

// @public (undocumented)
export type GroupNode = {
    type: BoolExpressionNodeTypes.group;
    op: string;
    left: BoolExpression;
    right?: BoolExpression;
};

// @public (undocumented)
export const ID_ATTR = "id";

// @public (undocumented)
export function indexBy(arr: any[], key: string): any;

// @public (undocumented)
export type InertKlassInstance<T extends NonNullable<KlassMeta["public"]>> = InertKlassInstanceProps<T> & KlassInstancePrimitiveProps;

// @public (undocumented)
export type InertKlassInstanceProps<T extends NonNullable<KlassMeta["public"]>> = OptionalProps<T, false, false> & RequiredProps<T, false, false>;

// @public (undocumented)
export const Interaction: Klass<InteractionPublicType>;

// @public (undocumented)
export type InteractionContext = {
    logContext?: any;
    [k: string]: any;
};

// @public (undocumented)
export type InteractionEvent = {
    interactionId: string;
    interactionName: string;
    activityId?: string;
} & InteractionEventArgs;

// @public (undocumented)
export type InteractionEventArgs = {
    user: EventUser;
    payload?: EventPayload;
    query?: EventQuery;
};

// @public (undocumented)
export type InteractionEventRecord = InteractionEvent & EntityIdRef;

// @public (undocumented)
export type InteractionInstanceType = KlassInstance<typeof Interaction, false>;

// @public (undocumented)
export type InteractionPublicType = {
    name: {
        type: 'string';
        collection: false;
        required: true;
    };
    conditions: {
        required: false;
        collection: false;
        type: (typeof Conditions | typeof Condition)[];
    };
    userAttributives: {
        required: false;
        collection: false;
        type: (typeof Attributives | typeof Attributive)[];
    };
    userRef: {
        type: typeof Attributive;
        collection: false;
    };
    action: {
        type: typeof Action;
        collection: false;
        required: true;
    };
    payload: {
        type: typeof Payload;
        collection: false;
    };
    sideEffects: {
        type: typeof SideEffect;
        collection: true;
        defaultValue: (...args: any[]) => KlassInstance<typeof SideEffect, any>[];
    };
    dataAttributives: {
        required: false;
        collection: false;
        type: (typeof DataAttributive | typeof DataAttributives)[];
    };
    data: {
        type: (typeof Entity | typeof Relation | typeof Computation)[];
        required: false;
        collection: false;
    };
    query: {
        type: typeof Query;
        collection: false;
    };
};

// @public (undocumented)
export type Klass<T extends NonNullable<KlassMeta["public"]>> = {
    new <U extends KlassOptions | ReactiveKlassOptions>(arg: object, options?: U): U extends ReactiveKlassOptions ? ReactiveKlassInstance<T> : InertKlassInstance<T>;
    create: (arg: KlassInstanceArgs<T>, options?: KlassOptions) => InertKlassInstance<T>;
    createReactive: (arg: KlassInstanceArgs<T>, options?: KlassOptions) => ReactiveKlassInstance<T>;
    displayName: string;
    isKlass: true;
    public: T;
    constraints: KlassMeta['constraints'];
    instances: (KlassInstance<Klass<T>, false> | KlassInstance<Klass<T>, true>)[];
    display?: KlassMeta['display'];
    stringify: (instance: InertKlassInstance<T> | ReactiveKlassInstance<T>) => string;
    parse: () => InertKlassInstance<T>;
    check: (data: object) => boolean;
    is: (arg: any) => boolean;
    clone: <V>(obj: V, deep: boolean) => V;
};

// @public (undocumented)
export const KlassByName: Map<string, Klass<any>>;

// Warning: (ae-forgotten-export) The symbol "KlassLikeType" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type KlassInstance<T extends KlassLikeType, U extends true | false> = U extends true ? ReactiveKlassInstance<T["public"]> : InertKlassInstance<T["public"]>;

// @public (undocumented)
export type KlassInstanceArgs<T extends NonNullable<KlassMeta["public"]>> = OptionalProps<T, false, true> & RequiredProps<T, false, true>;

// @public (undocumented)
export type KlassInstancePrimitiveProps = {
    uuid: string;
    _options: KlassOptions;
    _type: string;
};

// @public (undocumented)
export type KlassMeta = {
    name: string;
    display?: (obj: any) => string;
    constraints?: {
        [ruleName: string]: (thisInstance: object, allInstance: object[]) => Atom<boolean> | boolean;
    };
    public: {
        [key: string]: ClassMetaPublicItem;
    };
    is?: (obj: any) => boolean;
};

// @public (undocumented)
export type KlassOptions = {
    isReactive?: false;
    uuid?: string;
};

// Warning: (ae-forgotten-export) The symbol "IfReactiveCollectionProp" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type KlassProp<REACTIVE extends boolean, COLLECTION extends true | false | undefined, T> = IfReactiveCollectionProp<REACTIVE, COLLECTION, T>;

// @public (undocumented)
export const MapActivity: Klass<    {
    items: {
        type: Klass<    {
            activity: {
                type: Klass<    {
                    name: {
                        type: "string";
                        collection: false;
                        required: true;
                    };
                    interactions: {
                        type: Klass<InteractionPublicType>;
                        collection: true;
                        defaultValue: (...args: any[]) => (InertKlassInstance<InteractionPublicType> | ReactiveKlassInstance<InteractionPublicType>)[];
                    };
                    transfers: {
                        type: Klass<TransferPublicType>;
                        collection: true;
                        defaultValue: (...args: any[]) => (ReactiveKlassInstance<TransferPublicType> | InertKlassInstance<TransferPublicType>)[];
                    };
                    groups: {
                        type: Klass<ActivityGroupPublicType>;
                        collection: true;
                        defaultValue: (...args: any[]) => (ReactiveKlassInstance<ActivityGroupPublicType> | InertKlassInstance<ActivityGroupPublicType>)[];
                    };
                    gateways: {
                        type: Klass<GatewayPublicType>;
                        collection: true;
                        defaultValue: (...args: any[]) => (ReactiveKlassInstance<GatewayPublicType> | InertKlassInstance<GatewayPublicType>)[];
                    };
                    events: {
                        type: Klass<    {
                            name: {
                                type: "string";
                                required: true;
                            };
                        }>;
                        collection: true;
                        defaultValue: (...args: any[]) => (ReactiveKlassInstance<    {
                            name: {
                                type: "string";
                                required: true;
                            };
                        }> | InertKlassInstance<    {
                            name: {
                                type: "string";
                                required: true;
                            };
                        }>)[];
                    };
                }>;
                collection: false;
                required: true;
            };
            triggerInteractions: {
                type: Klass<InteractionPublicType>;
                collection: true;
                required: false;
            };
            map: {
                type: "function";
                collection: false;
                required: true;
            };
            computeTarget: {
                type: "function";
                collection: false;
                required: false;
            };
        }>;
        collection: true;
        required: true;
    };
    defaultValue: {
        type: "string";
        collection: false;
        required: false;
    };
}>;

// @public (undocumented)
export const MapActivityItem: Klass<    {
    activity: {
        type: Klass<    {
            name: {
                type: "string";
                collection: false;
                required: true;
            };
            interactions: {
                type: Klass<InteractionPublicType>;
                collection: true;
                defaultValue: (...args: any[]) => (InertKlassInstance<InteractionPublicType> | ReactiveKlassInstance<InteractionPublicType>)[];
            };
            transfers: {
                type: Klass<TransferPublicType>;
                collection: true;
                defaultValue: (...args: any[]) => (ReactiveKlassInstance<TransferPublicType> | InertKlassInstance<TransferPublicType>)[];
            };
            groups: {
                type: Klass<ActivityGroupPublicType>;
                collection: true;
                defaultValue: (...args: any[]) => (ReactiveKlassInstance<ActivityGroupPublicType> | InertKlassInstance<ActivityGroupPublicType>)[];
            };
            gateways: {
                type: Klass<GatewayPublicType>;
                collection: true;
                defaultValue: (...args: any[]) => (ReactiveKlassInstance<GatewayPublicType> | InertKlassInstance<GatewayPublicType>)[];
            };
            events: {
                type: Klass<    {
                    name: {
                        type: "string";
                        required: true;
                    };
                }>;
                collection: true;
                defaultValue: (...args: any[]) => (ReactiveKlassInstance<    {
                    name: {
                        type: "string";
                        required: true;
                    };
                }> | InertKlassInstance<    {
                    name: {
                        type: "string";
                        required: true;
                    };
                }>)[];
            };
        }>;
        collection: false;
        required: true;
    };
    triggerInteractions: {
        type: Klass<InteractionPublicType>;
        collection: true;
        required: false;
    };
    map: {
        type: "function";
        collection: false;
        required: true;
    };
    computeTarget: {
        type: "function";
        collection: false;
        required: false;
    };
}>;

// @public (undocumented)
export const MapInteraction: Klass<    {
    items: {
        type: Klass<    {
            interaction: {
                type: Klass<InteractionPublicType>;
                collection: false;
                required: true;
            };
            map: {
                type: "function";
                collection: false;
                required: true;
            };
            computeTarget: {
                type: "function";
                collection: false;
                required: false;
            };
        }>;
        collection: true;
        required: true;
    };
    defaultValue: {
        type: "string";
        collection: false;
        required: false;
    };
}>;

// @public (undocumented)
export const MapInteractionItem: Klass<    {
    interaction: {
        type: Klass<InteractionPublicType>;
        collection: false;
        required: true;
    };
    map: {
        type: "function";
        collection: false;
        required: true;
    };
    computeTarget: {
        type: "function";
        collection: false;
        required: false;
    };
}>;

// @public (undocumented)
export function mapObject(a: object, fn: (k: string, v: any) => any): {
    [k: string]: any;
};

// @public (undocumented)
export const MapRecordMutation: Klass<    {
    map: {
        type: "function";
        collection: false;
        required: true;
    };
    computeTarget: {
        type: "function";
        collection: false;
        required: false;
    };
}>;

// @public (undocumented)
export class MonoSystem implements System {
    constructor(db?: Database, logger?: SystemLogger);
    // (undocumented)
    conceptClass: Map<string, ReturnType<typeof createClass>>;
    // (undocumented)
    createActivity(activity: any): Promise<any>;
    // (undocumented)
    getActivity(query?: MatchExpressionData): Promise<any[]>;
    // (undocumented)
    getEvent(query?: MatchExpressionData): Promise<InteractionEvent[]>;
    // (undocumented)
    logger: SystemLogger;
    // (undocumented)
    saveEvent(event: InteractionEvent, mutationEvents?: RecordMutationEvent[]): Promise<any>;
    // (undocumented)
    setup(entities: KlassInstance<typeof Entity, false>[], relations: KlassInstance<typeof Relation, false>[], install?: boolean): any;
    // (undocumented)
    storage: Storage_2;
    // (undocumented)
    updateActivity(match: MatchExpressionData, activity: any): Promise<any>;
}

export { MutationEvent }

// @public (undocumented)
export class MysqlDB implements Database {
    constructor(database: string, options?: MysqlDBConfig);
    // (undocumented)
    close(): Promise<void>;
    // (undocumented)
    database: string;
    // (undocumented)
    db: Connection;
    // (undocumented)
    delete<T extends any>(sql: string, where: any[], name?: string): Promise<T[]>;
    // (undocumented)
    getAutoId(recordName: string): Promise<string>;
    // (undocumented)
    getPlaceholder(): () => string;
    // Warning: (ae-forgotten-export) The symbol "IDSystem_3" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    idSystem: IDSystem_3;
    // (undocumented)
    insert(sql: string, values: any[], name?: string): Promise<EntityIdRef>;
    // (undocumented)
    logger: DatabaseLogger;
    // (undocumented)
    mapToDBFieldType(type: string, collection?: boolean): string;
    // (undocumented)
    open(forceDrop?: boolean): Promise<void>;
    // (undocumented)
    options: MysqlDBConfig;
    // (undocumented)
    parseMatchExpression(key: string, value: [string, string], fieldName: string, fieldType: string, isReferenceValue: boolean, getReferenceFieldValue: (v: string) => string, p: () => string): {
        fieldValue: string;
        fieldParams: never[];
    } | undefined;
    // (undocumented)
    query<T extends any>(sql: string, where?: any[], name?: string): Promise<T[]>;
    // (undocumented)
    scheme(sql: string, name?: string): Promise<[mysql.QueryResult, mysql.FieldPacket[]]>;
    // (undocumented)
    update<T extends any>(sql: string, values: any[], idField?: string, name?: string): Promise<T[]>;
}

// @public (undocumented)
export type MysqlDBConfig = Omit<ConnectionOptions, 'database'> & {
    logger?: DatabaseLogger;
};

// @public (undocumented)
export const OperatorNames: {
    '||': string;
    '&&': string;
    '!': string;
};

// Warning: (ae-forgotten-export) The symbol "OmitNever" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "UnknownInstance" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "PrimitivePropType" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "PrimitivePropertyMap" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ExtractPrimitiveTypes" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type OptionalProps<T extends NonNullable<KlassMeta["public"]>, REACTIVE extends true | false, IS_ARG extends true | false> = Partial<OmitNever<{
    [Key in keyof T]: RequireWithoutDefaultAndComputed<T[Key], IS_ARG> extends true ? never : (T[Key]["instanceType"] extends Object ? KlassProp<REACTIVE, T[Key]["collection"], T[Key]["instanceType"]> : (T[Key]['type'] extends Klass<any> ? KlassProp<REACTIVE, T[Key]["collection"], InertKlassInstance<T[Key]['type']['public']>> : T[Key]['type'] extends Klass<any>[] ? KlassProp<REACTIVE, T[Key]["collection"], KlassInstance<Klass<any>, false> & UnknownInstance> : T[Key]['type'] extends PrimitivePropType ? KlassProp<REACTIVE, T[Key]["collection"], PrimitivePropertyMap[T[Key]['type']]> : T[Key]['type'] extends PrimitivePropType[] ? ExtractPrimitiveTypes<REACTIVE, T[Key]["collection"], T[Key]['type']> : never));
}>>;

// Warning: (ae-forgotten-export) The symbol "ParseAtomNameToObjectType" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function parse<T>(exp: string, options?: any[], parseAtomNameToObject?: ParseAtomNameToObjectType): BoolExp<T>;

// @public (undocumented)
export const Payload: Klass<{
    items: {
        type: Klass<{
            name: {
                type: "string";
                required: true;
            };
            attributives: {
                type: (Klass<{
                    stringContent: {
                        type: "string";
                    };
                    content: {
                        type: "function";
                        required: true;
                        collection: false;
                    };
                    name: {
                        type: "string";
                    };
                    isRef: {
                        type: "boolean";
                    };
                }> | Klass<{
                    content: {
                        type: (Klass<{
                            type: {
                                type: "string";
                                required: true;
                                collection: false;
                                defaultValue: () => string;
                            };
                            data: {
                                instanceType: ReactiveKlassInstance<    {
                                    content: {
                                        type: "function";
                                        required: true;
                                        collection: false;
                                    };
                                }> | InertKlassInstance<    {
                                    content: {
                                        type: "function";
                                        required: true;
                                        collection: false;
                                    };
                                }>;
                                required: true;
                                collection: false;
                            };
                        }> | Klass<{
                            type: {
                                type: "string";
                                required: true;
                                collection: false;
                                defaultValue: () => string;
                            };
                            operator: {
                                type: "string";
                                required: true;
                                collection: false;
                                options: string[];
                                defaultValue: () => string;
                            };
                            left: {
                                instanceType: InertKlassInstance<    {
                                    type: {
                                        type: "string";
                                        required: true;
                                        collection: false;
                                        defaultValue: () => string;
                                    };
                                    data: {
                                        instanceType: ReactiveKlassInstance<    {
                                            content: {
                                                type: "function";
                                                required: true;
                                                collection: false;
                                            };
                                        }> | InertKlassInstance<    {
                                            content: {
                                                type: "function";
                                                required: true;
                                                collection: false;
                                            };
                                        }>;
                                        required: true;
                                        collection: false;
                                    };
                                }> | UnwrappedBoolExpressionInstanceType<any>;
                                required: true;
                                collection: false;
                            };
                            right: {
                                instanceType: InertKlassInstance<    {
                                    type: {
                                        type: "string";
                                        required: true;
                                        collection: false;
                                        defaultValue: () => string;
                                    };
                                    data: {
                                        instanceType: ReactiveKlassInstance<    {
                                            content: {
                                                type: "function";
                                                required: true;
                                                collection: false;
                                            };
                                        }> | InertKlassInstance<    {
                                            content: {
                                                type: "function";
                                                required: true;
                                                collection: false;
                                            };
                                        }>;
                                        required: true;
                                        collection: false;
                                    };
                                }> | UnwrappedBoolExpressionInstanceType<any>;
                                required: false;
                                collection: false;
                            };
                        }>)[];
                        collection: false;
                        required: false;
                    };
                }>)[];
                collection: false;
            };
            base: {
                type: Klass<{
                    name: {
                        type: "string";
                        collection: false;
                        required: true;
                        constraints: {
                            nameFormat({ name }: {
                                name: Atom<string>;
                            }): Atom<boolean>;
                        };
                    };
                    computedData: {
                        type: Klass<any>[];
                        collection: false;
                        required: false;
                    };
                    properties: {
                        type: Klass<{
                            name: {
                                type: "string";
                                required: true;
                                collection: false;
                                constraints: {
                                    format({ name }: {
                                        name: Atom<string>;
                                    }): Atom<boolean>;
                                    length({ name }: {
                                        name: Atom<string>;
                                    }): Atom<boolean>;
                                };
                            };
                            type: {
                                type: "string";
                                required: true;
                                collection: false;
                                options: PropertyTypes[];
                            };
                            collection: {
                                type: "boolean";
                                required: true;
                                collection: false;
                                defaultValue(): boolean;
                            };
                            args: {
                                computedType: (values: {
                                    type: PropertyTypes;
                                }) => string;
                            };
                            computedData: {
                                collection: false;
                                type: Klass<any>[];
                                required: false;
                            };
                            computed: {
                                required: false;
                                type: "function";
                                collection: false;
                            };
                        }>;
                        collection: true;
                        required: true;
                        constraints: {
                            eachNameUnique({ properties }: any): Atom<boolean>;
                        };
                        defaultValue(): never[];
                    };
                    isRef: {
                        required: true;
                        collection: false;
                        type: "boolean";
                        defaultValue: () => boolean;
                    };
                }>;
                required: true;
                collection: false;
            };
            isRef: {
                type: "boolean";
                collection: false;
                defaultValue: () => boolean;
            };
            required: {
                type: "boolean";
                collection: false;
                defaultValue: () => boolean;
            };
            isCollection: {
                type: "boolean";
                collection: false;
                defaultValue: () => boolean;
            };
            itemRef: {
                collection: false;
                required: false;
                type: (Klass<{
                    name: {
                        type: "string";
                        collection: false;
                        required: true;
                        constraints: {
                            nameFormat({ name }: {
                                name: Atom<string>;
                            }): Atom<boolean>;
                        };
                    };
                    computedData: {
                        type: Klass<any>[];
                        collection: false;
                        required: false;
                    };
                    properties: {
                        type: Klass<{
                            name: {
                                type: "string";
                                required: true;
                                collection: false;
                                constraints: {
                                    format({ name }: {
                                        name: Atom<string>;
                                    }): Atom<boolean>;
                                    length({ name }: {
                                        name: Atom<string>;
                                    }): Atom<boolean>;
                                };
                            };
                            type: {
                                type: "string";
                                required: true;
                                collection: false;
                                options: PropertyTypes[];
                            };
                            collection: {
                                type: "boolean";
                                required: true;
                                collection: false;
                                defaultValue(): boolean;
                            };
                            args: {
                                computedType: (values: {
                                    type: PropertyTypes;
                                }) => string;
                            };
                            computedData: {
                                collection: false;
                                type: Klass<any>[];
                                required: false;
                            };
                            computed: {
                                required: false;
                                type: "function";
                                collection: false;
                            };
                        }>;
                        collection: true;
                        required: true;
                        constraints: {
                            eachNameUnique({ properties }: any): Atom<boolean>;
                        };
                        defaultValue(): never[];
                    };
                    isRef: {
                        required: true;
                        collection: false;
                        type: "boolean";
                        defaultValue: () => boolean;
                    };
                }> | Klass<{
                    stringContent: {
                        type: "string";
                    };
                    content: {
                        type: "function";
                        required: true;
                        collection: false;
                    };
                    name: {
                        type: "string";
                    };
                    isRef: {
                        type: "boolean";
                    };
                }>)[];
            };
        }>;
        collection: true;
        required: true;
        defaultValue: () => never[];
    };
}>;

// @public (undocumented)
export const PayloadItem: Klass<{
    name: {
        type: "string";
        required: true;
    };
    attributives: {
        type: (Klass<{
            stringContent: {
                type: "string";
            };
            content: {
                type: "function";
                required: true;
                collection: false;
            };
            name: {
                type: "string";
            };
            isRef: {
                type: "boolean";
            };
        }> | Klass<{
            content: {
                type: (Klass<{
                    type: {
                        type: "string";
                        required: true;
                        collection: false;
                        defaultValue: () => string;
                    };
                    data: {
                        instanceType: ReactiveKlassInstance<    {
                            content: {
                                type: "function";
                                required: true;
                                collection: false;
                            };
                        }> | InertKlassInstance<    {
                            content: {
                                type: "function";
                                required: true;
                                collection: false;
                            };
                        }>;
                        required: true;
                        collection: false;
                    };
                }> | Klass<{
                    type: {
                        type: "string";
                        required: true;
                        collection: false;
                        defaultValue: () => string;
                    };
                    operator: {
                        type: "string";
                        required: true;
                        collection: false;
                        options: string[];
                        defaultValue: () => string;
                    };
                    left: {
                        instanceType: InertKlassInstance<    {
                            type: {
                                type: "string";
                                required: true;
                                collection: false;
                                defaultValue: () => string;
                            };
                            data: {
                                instanceType: ReactiveKlassInstance<    {
                                    content: {
                                        type: "function";
                                        required: true;
                                        collection: false;
                                    };
                                }> | InertKlassInstance<    {
                                    content: {
                                        type: "function";
                                        required: true;
                                        collection: false;
                                    };
                                }>;
                                required: true;
                                collection: false;
                            };
                        }> | UnwrappedBoolExpressionInstanceType<any>;
                        required: true;
                        collection: false;
                    };
                    right: {
                        instanceType: InertKlassInstance<    {
                            type: {
                                type: "string";
                                required: true;
                                collection: false;
                                defaultValue: () => string;
                            };
                            data: {
                                instanceType: ReactiveKlassInstance<    {
                                    content: {
                                        type: "function";
                                        required: true;
                                        collection: false;
                                    };
                                }> | InertKlassInstance<    {
                                    content: {
                                        type: "function";
                                        required: true;
                                        collection: false;
                                    };
                                }>;
                                required: true;
                                collection: false;
                            };
                        }> | UnwrappedBoolExpressionInstanceType<any>;
                        required: false;
                        collection: false;
                    };
                }>)[];
                collection: false;
                required: false;
            };
        }>)[];
        collection: false;
    };
    base: {
        type: Klass<{
            name: {
                type: "string";
                collection: false;
                required: true;
                constraints: {
                    nameFormat({ name }: {
                        name: Atom<string>;
                    }): Atom<boolean>;
                };
            };
            computedData: {
                type: Klass<any>[];
                collection: false;
                required: false;
            };
            properties: {
                type: Klass<{
                    name: {
                        type: "string";
                        required: true;
                        collection: false;
                        constraints: {
                            format({ name }: {
                                name: Atom<string>;
                            }): Atom<boolean>;
                            length({ name }: {
                                name: Atom<string>;
                            }): Atom<boolean>;
                        };
                    };
                    type: {
                        type: "string";
                        required: true;
                        collection: false;
                        options: PropertyTypes[];
                    };
                    collection: {
                        type: "boolean";
                        required: true;
                        collection: false;
                        defaultValue(): boolean;
                    };
                    args: {
                        computedType: (values: {
                            type: PropertyTypes;
                        }) => string;
                    };
                    computedData: {
                        collection: false;
                        type: Klass<any>[];
                        required: false;
                    };
                    computed: {
                        required: false;
                        type: "function";
                        collection: false;
                    };
                }>;
                collection: true;
                required: true;
                constraints: {
                    eachNameUnique({ properties }: any): Atom<boolean>;
                };
                defaultValue(): never[];
            };
            isRef: {
                required: true;
                collection: false;
                type: "boolean";
                defaultValue: () => boolean;
            };
        }>;
        required: true;
        collection: false;
    };
    isRef: {
        type: "boolean";
        collection: false;
        defaultValue: () => boolean;
    };
    required: {
        type: "boolean";
        collection: false;
        defaultValue: () => boolean;
    };
    isCollection: {
        type: "boolean";
        collection: false;
        defaultValue: () => boolean;
    };
    itemRef: {
        collection: false;
        required: false;
        type: (Klass<{
            name: {
                type: "string";
                collection: false;
                required: true;
                constraints: {
                    nameFormat({ name }: {
                        name: Atom<string>;
                    }): Atom<boolean>;
                };
            };
            computedData: {
                type: Klass<any>[];
                collection: false;
                required: false;
            };
            properties: {
                type: Klass<{
                    name: {
                        type: "string";
                        required: true;
                        collection: false;
                        constraints: {
                            format({ name }: {
                                name: Atom<string>;
                            }): Atom<boolean>;
                            length({ name }: {
                                name: Atom<string>;
                            }): Atom<boolean>;
                        };
                    };
                    type: {
                        type: "string";
                        required: true;
                        collection: false;
                        options: PropertyTypes[];
                    };
                    collection: {
                        type: "boolean";
                        required: true;
                        collection: false;
                        defaultValue(): boolean;
                    };
                    args: {
                        computedType: (values: {
                            type: PropertyTypes;
                        }) => string;
                    };
                    computedData: {
                        collection: false;
                        type: Klass<any>[];
                        required: false;
                    };
                    computed: {
                        required: false;
                        type: "function";
                        collection: false;
                    };
                }>;
                collection: true;
                required: true;
                constraints: {
                    eachNameUnique({ properties }: any): Atom<boolean>;
                };
                defaultValue(): never[];
            };
            isRef: {
                required: true;
                collection: false;
                type: "boolean";
                defaultValue: () => boolean;
            };
        }> | Klass<{
            stringContent: {
                type: "string";
            };
            content: {
                type: "function";
                required: true;
                collection: false;
            };
            name: {
                type: "string";
            };
            isRef: {
                type: "boolean";
            };
        }>)[];
    };
}>;

// @public (undocumented)
export class PostgreSQLDB implements Database {
    constructor(database: string, options?: PostgreSQLDBConfig);
    // (undocumented)
    close(): Promise<void>;
    // (undocumented)
    database: string;
    // Warning: (ae-forgotten-export) The symbol "Client" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    db: InstanceType<typeof Client>;
    // (undocumented)
    delete<T extends any>(sql: string, where: any[], name?: string): Promise<T[]>;
    // (undocumented)
    getAutoId(recordName: string): Promise<string>;
    // (undocumented)
    getPlaceholder(): () => string;
    // Warning: (ae-forgotten-export) The symbol "IDSystem_2" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    idSystem: IDSystem_2;
    // (undocumented)
    insert(sql: string, values: any[], name?: string): Promise<EntityIdRef>;
    // (undocumented)
    logger: DatabaseLogger;
    // (undocumented)
    mapToDBFieldType(type: string, collection?: boolean): string;
    // (undocumented)
    open(forceDrop?: boolean): Promise<void>;
    // (undocumented)
    options: PostgreSQLDBConfig;
    // (undocumented)
    parseMatchExpression(key: string, value: [string, string], fieldName: string, fieldType: string, isReferenceValue: boolean, getReferenceFieldValue: (v: string) => string, p: () => string): {
        fieldValue: string;
        fieldParams: string[];
    } | undefined;
    // (undocumented)
    query<T extends any>(sql: string, where?: any[], name?: string): Promise<T[]>;
    // (undocumented)
    scheme(sql: string, name?: string): Promise<pg.QueryResult<any>>;
    // (undocumented)
    update<T extends any>(sql: string, values: any[], idField?: string, name?: string): Promise<T[]>;
}

// @public (undocumented)
export type PostgreSQLDBConfig = Omit<ClientConfig, 'database'> & {
    logger?: DatabaseLogger;
};

// @public (undocumented)
export const Property: Klass<{
    name: {
        type: "string";
        required: true;
        collection: false;
        constraints: {
            format({ name }: {
                name: Atom<string>;
            }): Atom<boolean>;
            length({ name }: {
                name: Atom<string>;
            }): Atom<boolean>;
        };
    };
    type: {
        type: "string";
        required: true;
        collection: false;
        options: PropertyTypes[];
    };
    collection: {
        type: "boolean";
        required: true;
        collection: false;
        defaultValue(): boolean;
    };
    args: {
        computedType: (values: {
            type: PropertyTypes;
        }) => string;
    };
    computedData: {
        collection: false;
        type: Klass<any>[];
        required: false;
    };
    computed: {
        required: false;
        type: "function";
        collection: false;
    };
}>;

// @public (undocumented)
export const PropertyTypeMap: {
    string: string;
    number: string;
    boolean: string;
};

// @public (undocumented)
export enum PropertyTypes {
    // (undocumented)
    Boolean = "boolean",
    // (undocumented)
    Number = "number",
    // (undocumented)
    String = "string"
}

// @public (undocumented)
export const Query: Klass<    {
    items: {
        type: Klass<    {
            name: {
                type: "string";
                required: true;
                collection: false;
            };
            value: {
                type: "string";
                required: true;
                collection: false;
            };
        }>[];
        required: true;
        collection: true;
    };
}>;

// @public (undocumented)
export const QueryItem: Klass<    {
    name: {
        type: "string";
        required: true;
        collection: false;
    };
    value: {
        type: "string";
        required: true;
        collection: false;
    };
}>;

// @public (undocumented)
export type ReactiveKlassInstance<T extends NonNullable<KlassMeta["public"]>> = ReactiveKlassInstanceProps<T> & KlassInstancePrimitiveProps;

// @public (undocumented)
export type ReactiveKlassInstanceProps<T extends NonNullable<KlassMeta["public"]>> = OptionalProps<T, true, false> & RequiredProps<T, true, false>;

// @public (undocumented)
export type ReactiveKlassOptions = Omit<KlassOptions, 'isReactive'> & {
    isReactive: true;
};

// @public (undocumented)
export type RecordMutationCallback = (mutationEvents: RecordMutationEvent[]) => Promise<{
    events?: RecordMutationEvent[];
} | undefined | void>;

// @public (undocumented)
export type RecordMutationEvent = {
    recordName: string;
    type: 'create' | 'update' | 'delete';
    keys?: string[];
    record?: EntityIdRef & {
        [key: string]: any;
    };
    oldRecord?: EntityIdRef & {
        [key: string]: any;
    };
};

// @public (undocumented)
export const RecordMutationSideEffect: Klass<{
    name: {
        type: "string";
        collection: false;
        required: true;
    };
    record: {
        type: (Klass<{
            name: {
                type: "string";
                collection: false;
                required: true;
                constraints: {
                    nameFormat({ name }: {
                        name: Atom<string>;
                    }): Atom<boolean>;
                };
            };
            computedData: {
                type: Klass<any>[];
                collection: false;
                required: false;
            };
            properties: {
                type: Klass<{
                    name: {
                        type: "string";
                        required: true;
                        collection: false;
                        constraints: {
                            format({ name }: {
                                name: Atom<string>;
                            }): Atom<boolean>;
                            length({ name }: {
                                name: Atom<string>;
                            }): Atom<boolean>;
                        };
                    };
                    type: {
                        type: "string";
                        required: true;
                        collection: false;
                        options: PropertyTypes[];
                    };
                    collection: {
                        type: "boolean";
                        required: true;
                        collection: false;
                        defaultValue(): boolean;
                    };
                    args: {
                        computedType: (values: {
                            type: PropertyTypes;
                        }) => string;
                    };
                    computedData: {
                        collection: false;
                        type: Klass<any>[];
                        required: false;
                    };
                    computed: {
                        required: false;
                        type: "function";
                        collection: false;
                    };
                }>;
                collection: true;
                required: true;
                constraints: {
                    eachNameUnique({ properties }: any): Atom<boolean>;
                };
                defaultValue(): never[];
            };
            isRef: {
                required: true;
                collection: false;
                type: "boolean";
                defaultValue: () => boolean;
            };
        }> | Klass<RelationPublic>)[];
        collection: false;
        required: true;
    };
    content: {
        type: "function";
        collection: false;
        required: true;
    };
}>;

// @public (undocumented)
export const Relation: Klass<RelationPublic>;

// @public (undocumented)
export const RelationBasedAny: Klass<    {
    relation: {
        type: Klass<RelationPublic>;
        collection: false;
        required: true;
    };
    relationDirection: {
        type: "string";
        collection: false;
        required: true;
        defaultValue: () => string;
    };
    match: {
        type: "function";
        collection: false;
        required: true;
    };
}>;

// @public (undocumented)
export const RelationBasedEvery: Klass<    {
    relation: {
        type: Klass<RelationPublic>;
        collection: false;
        required: true;
    };
    relationDirection: {
        type: "string";
        collection: false;
        required: true;
        defaultValue: () => string;
    };
    match: {
        type: "function";
        collection: false;
        required: true;
    };
    notEmpty: {
        type: "boolean";
        collection: false;
        required: false;
    };
}>;

// @public (undocumented)
export const RelationBasedWeightedSummation: Klass<    {
    relations: {
        type: Klass<    {
            relation: {
                type: Klass<RelationPublic>;
                collection: false;
                required: true;
            };
            relationDirection: {
                type: "string";
                collection: false;
                required: true;
                defaultValue: () => string;
            };
        }>;
        collection: true;
        required: true;
    };
    matchRelationToWeight: {
        type: "function";
        collection: false;
        required: true;
    };
}>;

// @public (undocumented)
export const RelationCount: Klass<    {
    relation: {
        type: Klass<RelationPublic>;
        collection: false;
        required: true;
    };
    relationDirection: {
        type: "string";
        collection: false;
        required: true;
        defaultValue: () => string;
    };
    match: {
        type: "function";
        collection: false;
        required: true;
    };
}>;

// @public (undocumented)
export type RelationPublic = {
    name: {
        type: 'string';
        required: false;
        collection: false;
        computed: (relation: any) => any;
    };
    source: {
        type: typeof Entity | Klass<RelationPublic>;
        required: true;
        collection: false;
        options: () => (KlassInstance<typeof Entity, any> | KlassInstance<Klass<RelationPublic>, any>)[];
    };
    sourceProperty: {
        type: 'string';
        required: true;
        collection: false;
        constraints: {
            [ruleName: string]: ((thisProp: any, thisEntity: object) => Atom<boolean> | boolean | any[]) | Function | string;
        };
    };
    target: {
        type: typeof Entity;
        required: true;
        collection: false;
        options: () => (KlassInstance<typeof Entity, any> | KlassInstance<Klass<RelationPublic>, any>)[];
    };
    targetProperty: {
        type: 'string';
        required: true;
        collection: false;
        constraints: {
            [ruleName: string]: ((thisProp: any, thisEntity: object) => Atom<boolean> | boolean | any[]) | Function | string;
        };
    };
    isTargetReliance: {
        type: 'boolean';
        required: true;
        collection: false;
        defaultValue: () => boolean;
    };
    relType: {
        type: 'string';
        collection: false;
        required: true;
        options: () => string[];
        defaultValue: () => [string];
    };
    computedData: {
        type: Klass<any>[];
        collection: false;
        required: false;
    };
    properties: {
        type: typeof Property;
        collection: true;
        required: true;
        constraints: {
            [ruleName: string]: ((thisProp: any, thisEntity: object) => Atom<boolean> | boolean | any[]) | Function | string;
        };
        defaultValue: () => any[];
    };
};

// @public (undocumented)
export function removeAllInstance(): void;

// @public (undocumented)
export type RequiredProps<T extends NonNullable<KlassMeta["public"]>, REACTIVE extends true | false, IS_ARG extends true | false> = OmitNever<{
    [Key in keyof T]: RequireWithoutDefaultAndComputed<T[Key], IS_ARG> extends true ? (T[Key]["instanceType"] extends Object ? KlassProp<REACTIVE, T[Key]["collection"], T[Key]["instanceType"]> : (T[Key]['type'] extends Klass<any> ? KlassProp<REACTIVE, T[Key]["collection"], InertKlassInstance<T[Key]['type']['public']>> : T[Key]['type'] extends Klass<any>[] ? KlassProp<REACTIVE, T[Key]["collection"], KlassInstance<Klass<any>, false> & UnknownInstance> : T[Key]['type'] extends PrimitivePropType ? KlassProp<REACTIVE, T[Key]["collection"], PrimitivePropertyMap[T[Key]['type']]> : T[Key]['type'] extends PrimitivePropType[] ? ExtractPrimitiveTypes<REACTIVE, T[Key]["collection"], T[Key]['type']> : never)) : never;
}>;

// Warning: (ae-forgotten-export) The symbol "DefaultValueType" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ComputedValueType" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type RequireWithoutDefaultAndComputed<T extends ClassMetaPublicItem, IS_ARG extends true | false> = IS_ARG extends true ? (T["defaultValue"] extends DefaultValueType ? false : T["computed"] extends ComputedValueType ? false : T["required"] extends true ? true : false) : (T["defaultValue"] extends DefaultValueType ? true : T["computed"] extends ComputedValueType ? true : T["required"] extends true ? true : false);

// @public (undocumented)
export const ROW_ID_ATTR = "_rowId";

// @public (undocumented)
export const SideEffect: Klass<{
    name: {
        type: "string";
        required: true;
        collection: false;
    };
    handle: {
        type: "function";
        required: true;
        collection: false;
    };
}>;

// @public (undocumented)
export class SQLiteDB implements Database {
    constructor(file?: string, options?: SQLiteDBOptions | undefined);
    // (undocumented)
    close(): void;
    // (undocumented)
    db: InstanceType<typeof SQLite>;
    // (undocumented)
    delete(sql: string, where: any[], name?: string): Promise<any[]>;
    // (undocumented)
    file: string;
    // (undocumented)
    getAutoId(recordName: string): Promise<string>;
    // Warning: (ae-forgotten-export) The symbol "IDSystem" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    idSystem: IDSystem;
    // (undocumented)
    insert(sql: string, values: any[], name?: string): Promise<EntityIdRef>;
    // (undocumented)
    logger: DatabaseLogger;
    // (undocumented)
    mapToDBFieldType(type: string, collection?: boolean): string;
    // (undocumented)
    open(): Promise<void>;
    // (undocumented)
    options?: SQLiteDBOptions | undefined;
    // (undocumented)
    parseMatchExpression(key: string, value: [string, string], fieldName: string, fieldType: string, isReferenceValue: boolean, getReferenceFieldValue: (v: string) => string, p: () => string): {
        fieldValue: string;
        fieldParams: string[];
    } | undefined;
    // (undocumented)
    query<T extends any>(sql: string, where?: any[], name?: string): Promise<T[]>;
    // (undocumented)
    scheme(sql: string, name?: string): Promise<SQLite.RunResult>;
    // (undocumented)
    update(sql: string, values: any[], idField?: string, name?: string): Promise<any[]>;
}

// @public (undocumented)
export type SQLiteDBOptions = Parameters<typeof SQLite>[1] & {
    logger: DatabaseLogger;
};

// Warning: (ae-forgotten-export) The symbol "ServerOptions" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function startServer(controller: Controller, options: ServerOptions, dataAPIs?: DataAPIs): Promise<void>;

// @public (undocumented)
export const State: Klass<{
    name: {
        type: "string";
        required: true;
        collection: false;
        constraints: {
            format({ name }: {
                name: Atom<string>;
            }): Atom<boolean>;
            length({ name }: {
                name: Atom<string>;
            }): Atom<boolean>;
        };
    };
    type: {
        type: "string";
        required: true;
        collection: false;
        options: PropertyTypes[];
    };
    collection: {
        type: "boolean";
        required: true;
        collection: false;
        defaultValue(): boolean;
    };
    args: {
        computedType: (values: {
            type: PropertyTypes;
        }) => string;
    };
    computedData: {
        collection: false;
        type: Klass<any>[];
        required: false;
    };
}>;

// @public (undocumented)
export const StateMachine: Klass<    {
    states: {
        type: Klass<    {
            value: {
                type: ("string" | "number" | "boolean" | "object" | "null")[];
                collection: false;
                required: false;
            };
            propertyHandle: {
                type: "function";
                required: false;
                collection: false;
            };
        }>;
        collection: true;
        required: true;
    };
    transfers: {
        type: Klass<    {
            triggerInteraction: {
                type: Klass<InteractionPublicType>;
                collection: false;
                required: true;
            };
            fromState: {
                type: Klass<    {
                    value: {
                        type: ("string" | "number" | "boolean" | "object" | "null")[];
                        collection: false;
                        required: false;
                    };
                    propertyHandle: {
                        type: "function";
                        required: false;
                        collection: false;
                    };
                }>;
                collection: false;
                required: true;
            };
            toState: {
                type: Klass<    {
                    value: {
                        type: ("string" | "number" | "boolean" | "object" | "null")[];
                        collection: false;
                        required: false;
                    };
                    propertyHandle: {
                        type: "function";
                        required: false;
                        collection: false;
                    };
                }>;
                collection: false;
                required: true;
            };
            handleType: {
                type: "string";
            };
            handle: {
                type: "function";
                collection: false;
                required: true;
            };
        }>;
        collection: true;
        required: true;
    };
    defaultState: {
        type: Klass<    {
            value: {
                type: ("string" | "number" | "boolean" | "object" | "null")[];
                collection: false;
                required: false;
            };
            propertyHandle: {
                type: "function";
                required: false;
                collection: false;
            };
        }>;
        collection: false;
        required: true;
    };
}>;

// @public (undocumented)
export const StateNode: Klass<    {
    value: {
        type: ("string" | "number" | "boolean" | "object" | "null")[];
        collection: false;
        required: false;
    };
    propertyHandle: {
        type: "function";
        required: false;
        collection: false;
    };
}>;

// @public (undocumented)
export const StateTransfer: Klass<    {
    triggerInteraction: {
        type: Klass<InteractionPublicType>;
        collection: false;
        required: true;
    };
    fromState: {
        type: Klass<    {
            value: {
                type: ("string" | "number" | "boolean" | "object" | "null")[];
                collection: false;
                required: false;
            };
            propertyHandle: {
                type: "function";
                required: false;
                collection: false;
            };
        }>;
        collection: false;
        required: true;
    };
    toState: {
        type: Klass<    {
            value: {
                type: ("string" | "number" | "boolean" | "object" | "null")[];
                collection: false;
                required: false;
            };
            propertyHandle: {
                type: "function";
                required: false;
                collection: false;
            };
        }>;
        collection: false;
        required: true;
    };
    handleType: {
        type: "string";
    };
    handle: {
        type: "function";
        collection: false;
        required: true;
    };
}>;

// @public (undocumented)
type Storage_2 = {
    map: any;
    beginTransaction: (transactionName?: string) => Promise<any>;
    commitTransaction: (transactionName?: string) => Promise<any>;
    rollbackTransaction: (transactionName?: string) => Promise<any>;
    get: (itemName: string, id: string, initialValue?: any) => Promise<any>;
    set: (itemName: string, id: string, value: any, events?: RecordMutationEvent[]) => Promise<any>;
    setup: (entities: KlassInstance<typeof Entity, false>[], relations: KlassInstance<typeof Relation, false>[], createTables?: boolean) => any;
    findOne: (entityName: string, ...arg: any[]) => Promise<any>;
    update: (entityName: string, ...arg: any[]) => Promise<any>;
    find: (entityName: string, ...arg: any[]) => Promise<any[]>;
    create: (entityName: string, data: any, events?: RecordMutationEvent[]) => Promise<any>;
    delete: (entityName: string, data: any, events?: RecordMutationEvent[]) => Promise<any>;
    findOneRelationByName: (relationName: string, ...arg: any[]) => Promise<any>;
    findRelationByName: (relationName: string, ...arg: any[]) => Promise<any>;
    updateRelationByName: (relationName: string, matchExpressionData: any, rawData: any, events?: RecordMutationEvent[]) => Promise<any>;
    removeRelationByName: (relationName: string, matchExpressionData: any, events?: RecordMutationEvent[]) => Promise<any>;
    addRelationByNameById: (relationName: string, sourceEntityId: string, targetEntityId: string, rawData: any, events?: RecordMutationEvent[]) => Promise<any>;
    getRelationName: (...arg: any[]) => string;
    listen: (callback: RecordMutationCallback) => any;
};
export { Storage_2 as Storage }

// @public (undocumented)
export function stringifyAllInstances(): string;

// @public (undocumented)
export function stringifyAttribute(obj: any): any;

// @public (undocumented)
export function stringifyInstance(obj: InertKlassInstance<any>): string;

// @public (undocumented)
export interface System {
    // (undocumented)
    conceptClass: Map<string, ReturnType<typeof createClass>>;
    // (undocumented)
    createActivity: (activity: any) => Promise<any>;
    // (undocumented)
    getActivity: (query?: any) => Promise<any[]>;
    // (undocumented)
    getEvent: (query: any) => Promise<InteractionEvent[]>;
    // (undocumented)
    logger: SystemLogger;
    // (undocumented)
    saveEvent: (interactionEvent: InteractionEvent, mutationEvents: RecordMutationEvent[]) => Promise<any>;
    // (undocumented)
    setup: (entities: KlassInstance<typeof Entity, false>[], relations: KlassInstance<typeof Relation, false>[], install?: boolean) => Promise<any>;
    // (undocumented)
    storage: Storage_2;
    // (undocumented)
    updateActivity: (match: any, activity: any) => Promise<any>;
}

// @public (undocumented)
export const SYSTEM_RECORD = "_System_";

// @public (undocumented)
export type SystemCallback = (...arg: any[]) => any;

// @public (undocumented)
export const systemEntity: InertKlassInstance<    {
    name: {
        type: "string";
        collection: false;
        required: true;
        constraints: {
            nameFormat({ name }: {
                name: Atom<string>;
            }): Atom<boolean>;
        };
    };
    computedData: {
        type: Klass<any>[];
        collection: false;
        required: false;
    };
    properties: {
        type: Klass<    {
            name: {
                type: "string";
                required: true;
                collection: false;
                constraints: {
                    format({ name }: {
                        name: Atom<string>;
                    }): Atom<boolean>;
                    length({ name }: {
                        name: Atom<string>;
                    }): Atom<boolean>;
                };
            };
            type: {
                type: "string";
                required: true;
                collection: false;
                options: PropertyTypes[];
            };
            collection: {
                type: "boolean";
                required: true;
                collection: false;
                defaultValue(): boolean;
            };
            args: {
                computedType: (values: {
                    type: PropertyTypes;
                }) => string;
            };
            computedData: {
                collection: false;
                type: Klass<any>[];
                required: false;
            };
            computed: {
                required: false;
                type: "function";
                collection: false;
            };
        }>;
        collection: true;
        required: true;
        constraints: {
            eachNameUnique({ properties }: any): Atom<boolean>;
        };
        defaultValue(): never[];
    };
    isRef: {
        required: true;
        collection: false;
        type: "boolean";
        defaultValue: () => boolean;
    };
}>;

// @public (undocumented)
export type SystemLogger = {
    error: (arg: SystemLogType) => any;
    info: (arg: SystemLogType) => any;
    debug: (arg: SystemLogType) => any;
    child: (fixed: object) => SystemLogger;
};

// @public (undocumented)
export type SystemLogType = {
    label: string;
    message: string;
    [k: string]: any;
};

// @public (undocumented)
export const Transfer: Klass<TransferPublicType>;

// @public (undocumented)
export type TransferInstanceType = KlassInstance<typeof Transfer, false>;

// @public (undocumented)
export type TransferPublicType = {
    name: {
        type: 'string';
        required: true;
        collection: false;
    };
    source: {
        type: (Klass<InteractionPublicType> | Klass<ActivityGroupPublicType> | Klass<GatewayPublicType>)[];
        required: true;
        collection: false;
    };
    target: {
        type: (Klass<InteractionPublicType> | Klass<ActivityGroupPublicType> | Klass<GatewayPublicType>)[];
        required: true;
        collection: false;
    };
};

// @public (undocumented)
export type UnwrapCollectionType<T extends Klass<any>[]> = {
    [Key in keyof T]: T[Key]["public"];
}[keyof T][number];

// @public (undocumented)
export type UnwrappedBoolExpressionInstanceType<T extends NonNullable<KlassMeta["public"]>> = {
    type: string;
    operator: string;
    left: UnwrappedBoolExpressionInstanceType<T> | KlassInstance<typeof BoolAtomData, false>;
    right?: UnwrappedBoolExpressionInstanceType<T> | KlassInstance<typeof BoolAtomData, false>;
} & KlassInstancePrimitiveProps;

// @public (undocumented)
export const USER_ENTITY = "User";

// @public (undocumented)
export type VariableNode = {
    type: BoolExpressionNodeTypes.variable;
    name: string;
    [k: string]: any;
};

// @public (undocumented)
export const WeightedSummation: Klass<    {
    records: {
        type: (Klass<    {
            name: {
                type: "string";
                collection: false;
                required: true;
                constraints: {
                    nameFormat({ name }: {
                        name: Atom<string>;
                    }): Atom<boolean>;
                };
            };
            computedData: {
                type: Klass<any>[];
                collection: false;
                required: false;
            };
            properties: {
                type: Klass<    {
                    name: {
                        type: "string";
                        required: true;
                        collection: false;
                        constraints: {
                            format({ name }: {
                                name: Atom<string>;
                            }): Atom<boolean>;
                            length({ name }: {
                                name: Atom<string>;
                            }): Atom<boolean>;
                        };
                    };
                    type: {
                        type: "string";
                        required: true;
                        collection: false;
                        options: PropertyTypes[];
                    };
                    collection: {
                        type: "boolean";
                        required: true;
                        collection: false;
                        defaultValue(): boolean;
                    };
                    args: {
                        computedType: (values: {
                            type: PropertyTypes;
                        }) => string;
                    };
                    computedData: {
                        collection: false;
                        type: Klass<any>[];
                        required: false;
                    };
                    computed: {
                        required: false;
                        type: "function";
                        collection: false;
                    };
                }>;
                collection: true;
                required: true;
                constraints: {
                    eachNameUnique({ properties }: any): Atom<boolean>;
                };
                defaultValue(): never[];
            };
            isRef: {
                required: true;
                collection: false;
                type: "boolean";
                defaultValue: () => boolean;
            };
        }> | Klass<RelationPublic>)[];
        collection: true;
        required: true;
    };
    matchRecordToWeight: {
        type: "function";
        collection: false;
        required: true;
    };
}>;

// Warnings were encountered during analysis:
//
// index.ts:13:55 - (ae-forgotten-export) The symbol "UnwrappedActivityInstanceType" needs to be exported by the entry point index.d.ts
// index.ts:13:55 - (ae-forgotten-export) The symbol "CommonAtomPublic" needs to be exported by the entry point index.d.ts
// index.ts:13:55 - (ae-forgotten-export) The symbol "ClassMetaPublicItem" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
