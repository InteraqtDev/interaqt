# @interaqt/runtime 文档大纲

## 一、使用文档（Usage Documentation）

### 1. 核心概念与响应式机制概览
- **1.1 框架的核心理念**
  - 基本范式：data = computation(events)
  - 声明式编程：描述"是什么"而非"怎么做"
  - 响应式计算：数据自动响应事件变化
  - 零手动数据操作：消除数据不一致

- **1.2 核心概念之间的关系**
  - **Entity（实体）**：数据的基本单位，如 User、Post
  - **Property（属性）**：实体的字段，可以是普通值或计算值
  - **Relation（关系）**：实体之间的连接，本质上也是特殊的 Entity
  - **Interaction（交互）**：用户触发的事件，是系统中数据变化的唯一来源
  - **Computation（计算）**：基于其他数据自动计算的值，是响应式的核心
  - **Activity（活动）**：多个相关 Interaction 的有序组合，实现复杂业务流程

- **1.3 响应式计算的工作原理**
  - **事件源**：所有数据变化都源于 Interaction（用户交互）
  - **变更追踪**：系统自动生成 Mutation Events（变更事件）
  - **依赖图**：Computation 声明了对哪些数据的依赖
  - **自动传播**：当依赖的数据变化时，相关计算自动重新执行
  - **增量计算**：使用增量算法避免全量重算，保证性能

- **1.4 数据流动示例**
  ```
  用户执行 Interaction（如点赞）
    ↓
  创建/修改 Relation（Like 关系）
    ↓
  生成 Mutation Event（创建事件）
    ↓
  触发相关 Computation（如 Count）
    ↓
  更新 Property（likeCount 自动 +1）
    ↓
  数据持久化到数据库
  ```

- **1.5 响应式计算的类型**
  - **Count**：计算集合中元素的数量（如点赞数、粉丝数）
  - **WeightedSummation**：加权求和（如总分、总价）
  - **Every/Any**：全部满足/任一满足的布尔判断
  - **Transform**：自定义转换函数，处理复杂计算逻辑
  - **StateMachine**：基于状态转换的计算
  - **MapInteractionToRecord**：将交互映射为实体关系
  - **MapInteractionToProperty**：将交互映射为属性值

- **1.6 系统架构层次**
  - **Storage 层**：提供 ORM 功能，处理数据持久化
  - **Runtime 层**：响应式引擎，处理计算调度和执行
  - **Shared 层**：定义核心概念和数据结构
  - **Controller**：协调各层工作，提供统一接口
  - **Scheduler**：管理计算任务的执行顺序和依赖

- **1.7 关键实现机制**
  - **ComputationSourceMap**：维护数据变更到计算的映射关系
  - **增量计算算法**：每种 Computation 都实现了 incrementalCompute 方法
  - **事务管理**：确保数据变更和计算更新的原子性
  - **异步计算支持**：允许计算中调用外部 API 或执行耗时操作
  - **过滤实体**：优化特定条件下的数据查询和计算

- **1.8 典型使用模式**
  - **内容系统**：文章、评论、点赞等，使用 Count 统计互动数据
  - **社交网络**：好友关系、动态更新，使用对称关系和 Transform
  - **审批流程**：多步骤、多角色，使用 Activity 和 StateMachine
  - **电商系统**：订单状态、库存计算，使用 WeightedSummation 和条件判断
  - **权限控制**：使用 Attributive 定义复杂的访问规则

### 2. 如何定义实体和属性
- **2.1 创建基本实体**
  - Entity.create() 的使用
  - 实体命名规范
  - 实体的基本结构

- **2.2 定义属性类型**
  - 基本类型：string、number、boolean
  - JSON 类型
  - 自定义类型

- **2.3 设置默认值**
  - 静态默认值
  - 动态默认值（函数）
  - 基于其他字段的默认值

- **2.4 使用计算属性**
  - getValue 函数
  - 基于当前记录的计算
  - 计算属性的持久化

### 3. 如何建立实体关系
- **3.1 创建一对一关系**
  - 用户与个人资料的关系
  - 关系的方向性
  - 关系的创建和删除

- **3.2 创建一对多关系**
  - 用户与帖子的关系
  - 在"一"端访问"多"端
  - 在"多"端访问"一"端

- **3.3 创建多对多关系**
  - 用户与标签的关系
  - 关系的双向访问
  - 关系属性的添加

- **3.4 使用对称关系**
  - 好友关系的实现
  - 对称关系的特殊性
  - 自动双向同步

### 4. 如何使用响应式计算
- **4.1 使用 Count 计算数量**
  - 统计关系数量
  - 条件计数
  - 实时更新机制

- **4.2 使用 WeightedSummation 加权求和**
  - 计算总分、总价
  - 定义权重函数

- **4.3 使用 Every 和 Any 进行条件判断**
  - 检查所有满足条件
  - 检查任一满足条件

- **4.4 使用 Transform 转换数据**
  - 数据格式转换
  - 聚合计算
  - 自定义转换逻辑

- **4.5 使用 StateMachine 管理状态**
  - 定义状态和转换
  - 状态变更触发

### 5. 如何定义和执行交互
- **5.1 创建基本交互**
  - Interaction.create() 的使用
  - 定义交互名称和动作
  - 无参数交互

- **5.2 定义交互参数（Payload）**
  - 添加必需参数
  - 添加可选参数
  - 参数类型和验证
  - 引用已有实体（isRef）

- **5.3 实现数据变更逻辑**
  - 在交互中创建实体
  - 在交互中更新实体
  - 在交互中删除实体
  - 在交互中建立关系

- **5.4 使用 Transform 来创建关系**
  - 将交互映射为关系
  - 自动创建关联
  - 条件映射

- **5.5 使用 StateMachine**
  - 将交互映射为属性值
  - 状态更新
  - 多交互映射

### 6. 如何使用定语（Attributive）控制权限
- **6.1 理解 Attributive 概念**
  - 什么是定语
  - 定语的作用
  - 定语与权限控制

- **6.2 为交互添加用户定语**
  - 限制谁可以执行交互
  - 基于角色的权限
  - 基于关系的权限
  - 动态权限判断

- **6.3 为实体添加定语**
  - 限制实体的创建
  - 限制实体的查询
  - 限制实体的更新

- **6.4 组合多个定语**
  - AND 逻辑组合
  - OR 逻辑组合
  - 复杂权限规则

### 7. 如何使用活动（Activity）管理流程
- **7.1 理解活动概念**
  - 活动 vs 独立交互
  - 状态机模型
  - 活动的生命周期

- **7.2 创建简单活动**
  - Activity.create() 的使用
  - 定义活动中的交互
  - 设置初始状态

- **7.3 定义状态转移（Transfer）**
  - 顺序转移
  - 条件转移
  - 并行转移
  - 循环转移

- **7.4 使用条件（Condition）控制流程**
  - 转移条件
  - 交互执行条件
  - 基于数据的条件
  - 基于用户的条件

- **7.5 实现复杂业务流程**
  - 多角色协作
  - 分支和合并
  - 超时处理
  - 异常处理

### 8. 如何使用过滤实体（Filtered Entity）
- **8.1 理解过滤实体**
  - 什么是过滤实体
  - 使用场景

- **8.2 创建过滤实体**
  - 基于属性过滤
  - 基于关系过滤

- **8.3 在过滤实体上操作**
  - 查询过滤后的数据
  - 更新过滤后的数据
  - 删除过滤后的数据

- **8.4 过滤实体与响应式计算**
  - 在计算中使用过滤实体

### 9. 如何使用异步计算
- **9.1 理解异步计算场景**
  - 何时需要异步计算
  - 异步计算的优势
  - 支持的计算类型

- **9.2 实现全局异步计算**
  - 调用外部 API
  - 处理返回结果
  - 错误处理

- **9.3 实现实体异步计算**
  - 为实体属性添加异步计算
 

- **9.4 实现关系异步计算**
  - 异步获取关联数据


### 10. 如何使用全局字典（Dictionary）
- **10.1 理解字典概念**
  - 全局状态管理
  - 字典 vs 实体
  - 使用场景

- **10.2 定义字典**
  - 创建全局配置
  - 创建全局统计
  - 创建缓存数据

- **10.3 字典的响应式计算**
  - 基于实体的全局统计
  - 基于交互的全局计数
  - 实时更新

- **10.4 在业务中使用字典**
  - 读取字典值
  - 基于字典的条件判断
  - 字典与交互的结合

### 11. 如何处理数据查询
- **11.1 基本查询操作**
  - findOne 查询单条
  - find 查询多条
  - 使用 MatchExp 构建条件

- **11.2 复杂查询条件**
  - 比较操作符
  - 逻辑组合（AND/OR）
  - 关联查询
  - 嵌套条件


- **11.4 关系数据的查询**
  - 预加载关联数据
  - 深度查询
  - 循环引用处理

### 12. 如何进行测试
- **12.1 搭建测试环境**
  - 测试数据库配置
  - 测试工具准备
  - Mock 数据

- **12.2 测试实体和关系**
  - 创建测试数据
  - 验证关系建立
  - 清理测试数据

- **12.3 测试响应式计算**
  - 验证自动更新
  - 测试计算正确性
  - 性能测试

- **12.4 测试交互和活动**
  - 模拟用户操作
  - 验证状态转换
  - 异常情况测试
  - 数据库索引策略
  - 计算缓存优化
  - 批量操作技巧
  - 监控和调优


### 13. API 参考（API Reference）
- **13.1 实体相关 API**
  - Entity.create()
  - Property.create()
  - Relation.create()
  - 完整参数说明

- **13.2 计算相关 API**
  - Count API
  - WeightedSummation API
  - Every/Any API
  - Transform API
  - StateMachine API
  - 自定义计算接口

- **13.3 交互相关 API**
  - Interaction.create()
  - Action.create()
  - Payload.create()
  - PayloadItem.create()

- **13.4 活动相关 API**
  - Activity.create()
  - Transfer.create()
  - Condition.create()
  - 活动生命周期 API

- **13.5 系统相关 API**
  - Controller API
  - System API
  - Storage API
  - 查询构建器 API

- **13.6 工具函数 API**
  - MatchExp 构建器
  - 类型定义和接口

## 二、开发文档（Development Documentation）

### 1. 架构设计（Architecture）
- **1.1 整体架构**
  - 模块划分
  - 数据流
  - 核心组件关系

- **1.2 Runtime 模块**
  - 响应式引擎设计
  - 调度器（Scheduler）
  - 控制器（Controller）
  - 活动管理器（ActivityManager）

- **1.3 Storage 模块**
  - ORM 设计
  - 查询构建器
  - 事务管理
  - 数据库适配器

- **1.4 Shared 模块**
  - 通用数据结构
  - 类型系统
  - 工具函数

### 2. 核心实现（Core Implementation）
- **2.1 响应式计算引擎**
  - ComputationSourceMap
  - 增量计算原理
  - 依赖追踪
  - 计算调度

- **2.2 数据变更追踪**
  - Mutation Event
  - 事件传播
  - 副作用处理

- **2.3 活动状态机**
  - 状态管理
  - 转移逻辑
  - 并发控制

- **2.4 存储层实现**
  - 实体表映射
  - 关系表设计
  - 查询优化
  - 事务处理

### 3. 扩展开发（Extension Development）
- **3.1 自定义计算类型**
  - DataBasedComputation 接口
  - 实现步骤
  - 注册机制
  - 示例代码

- **3.2 数据库适配器**
  - 适配器接口
  - 实现新的数据库支持
  - 测试要求

- **3.3 插件系统**
  - 插件架构
  - 钩子机制
  - 插件开发指南

### 4. 性能优化（Performance Optimization）
- **4.1 计算优化**
  - 增量计算策略
  - 缓存机制
  - 批处理

- **4.2 查询优化**
  - 索引策略
  - 查询计划
  - N+1 问题解决

- **4.3 内存管理**
  - 状态管理
  - 垃圾回收
  - 内存泄漏预防

### 5. 测试指南（Testing Guide）
- **5.1 测试框架**
  - Vitest 配置
  - 测试环境搭建
  - Mock 策略

- **5.2 测试类型**
  - 单元测试编写
  - 集成测试设计
  - 性能测试

- **5.3 测试最佳实践**
  - 测试覆盖率
  - 测试数据管理
  - CI/CD 集成

### 6. 贡献指南（Contributing Guide）
- **6.1 开发环境**
  - 环境搭建
  - 代码规范
  - 提交规范

- **6.2 贡献流程**
  - Issue 提交
  - Pull Request 流程
  - Code Review

- **6.3 发布流程**
  - 版本管理
  - 发布步骤
  - 文档更新

## 三、文档组织建议

### 1. 文档结构
```
docs/
├── usage/                    # 使用文档
│   ├── zh_cn/               # 中文文档
│   │   ├── guide/           # 指南
│   │   ├── tutorial/        # 教程
│   │   ├── api/             # API 参考
│   │   └── examples/        # 示例代码
│   └── en/                  # 英文文档
│       └── ...              # 同中文结构
├── development/             # 开发文档
│   ├── architecture/        # 架构设计
│   ├── implementation/      # 实现细节
│   ├── extension/           # 扩展开发
│   └── contributing/        # 贡献指南
└── api/                     # API 文档（自动生成）
```

### 2. 文档编写原则
- **渐进式**：从简单到复杂，循序渐进
- **示例驱动**：每个概念都配有代码示例
- **实用性**：关注实际使用场景
- **完整性**：覆盖所有重要功能
- **可维护性**：保持文档与代码同步

### 3. 文档工具建议
- **文档生成**：使用 TypeDoc 生成 API 文档
- **文档站点**：使用 VitePress 或 Docusaurus
- **示例管理**：独立的示例项目仓库
- **版本管理**：文档版本与代码版本对应

### 4. 优先级建议
1. **第一阶段**：完成快速开始、核心概念、基础 API 文档
2. **第二阶段**：完成教程、最佳实践、高级特性文档
3. **第三阶段**：完成开发文档、扩展指南、贡献指南

