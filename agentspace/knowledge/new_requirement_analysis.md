

# 概念
## 目标(Goal)
使用软件的目标，在当前框架中简称为目标。不涉及到详细的功能。
例如：管理现实中的图书，管理好友关系，记录生活内容。

## 需求(Requiremnt)
对软件的功能需求，在当前分析框架中简称为需求。应该表达为：
- 对数据的功能需求
- 对自动化的需求(暂不支持)
- 对通信能力的需求(赞不支持)

一个目标可以对应多个需求。

## 交互(Interaction)
用来满足用户具体需求的所设计的系统支持的交互行为。应该表达为：
```json
{
    condition: {交互动作的限制条件},
    role: {角色},
    action: {动作名称},
    payload: {负载信息. optional},
    数据: {当前交互关联的数据. optional}
    数据约束: {需求中的数据约束}
}
```

## 数据(Data)
从目标、需求中提取出来的概念。当前分析框架中支持的数据类型：
- 全局数据(Dictionary)。
- 实体(Entity)。
- 关系(Relation)。
- 属性(Property)。属于实体或者关系。
- 实体视图(View)。实体排序、分组、翻页、分组后的结果
- 聚合值(Agrregated Value)。聚合计算的结果，可以存在 Dictionary 或者 Entity/Relation 的 Property 上。通常还可以用来表达自定义的计算规则，例如加权的积分等等。

## 约束(Rules)
在需求中表达在角色、交互、数据上的约束条件。

# 分析步骤

## 1. 分析用户输入，补充完善目标。
用户的输入中有时是简单的模糊的目标，有时又是比较具体的需求。需要先识别出来，对比较模糊或者缺失的目标进行补充和细化。如何区分目标和需求：目标描述的应该是通过软件系统，要达成什么样的现实中的目标，而不是对软件系统能力的要求。

识别需要补充细化的场景，例如用户输入：管理图书馆
应该补充和细化：
- 管理图书
- 管理员工
- 管理读者

识别需要识别出来的具体场景，例如用户输入："每个读者不能同时借阅3本"。
应该直接识别为软件需求。

每个使用目标都应该有独立的编号。

### 📄 创建文档：`goals-analysis.md`
在这一步，agent应该创建一个目标分析文档，记录所有识别出的目标。

**文档模板：**
```markdown
# 目标分析

## 用户原始输入
[记录用户的原始需求描述]

## 识别的目标

### G001: [目标名称]
- **描述**: [详细描述该目标要达成的现实效果]
- **优先级**: [高/中/低]

### G002: [目标名称]
- **描述**: [详细描述]
- **优先级**: [高/中/低]

## 从用户输入中直接识别的需求
[如果用户输入中包含具体需求，在此列出，将在后续步骤中整合]
- [需求描述1]
- [需求描述2]
```

## 2. 功能需求分析

注意，我们目前只支持数据类型的需求。

人类使用软件的行为可以看作将一些人脑不适合的任务交给软件，例如大量的存储记忆、复杂的计算等。但最终还是为了自己大脑做更好的决策。
要做决策，就必须要从软件中读信息。所以我们可以以"读信息的需求"作为起始需求，以此来串联所有的其他需求。

### 2.1. 创建能满足目标的读需求

读需求的表达形式：
- 角色：例如"管理员"，"普通用户"
- 数据：使用我们支持"全局数据/实体/关系/属性/实体试图/聚合值"中的类型来表达。例如"用户总数(全局数据)"、"按名称排序的图书列表(实体视图)"
- 约束条件：例如："不能读被封禁的图书的详细内容"
- 目标：直接服务的目标。衍生出来的都需求可以没有目标。
- 父需求：需求衍生自哪个父需求。对于直接服务于目标的读需求可以没有。

### 2.2. 从读需求中衍生出创建、修改、删除的需求
从读需求中一定能衍生出创建数据的需求。但是否有修改和删除数据。要根据具体业务场景判断，有的场景中是不允许修改和删除的。

当衍生出创建、修改、删除的需求后，要继续从这些需求进行分析，是否要继续衍生出读需求。
因为用户在进行是否要创建、修改、删除的时候，有可能需要根据具体的场景进行决策。例如在修改某本图书的库存数量前，需要读取原本的库存数量进行核对，再决定是否修改。这样就衍生出来了"获取某本图书的库存数"的数据读需求。需求的衍生本质上基于数据来做的。

创建、修改、删除的需求的表达形式：
- 父需求：需求衍生自哪个父需求。
- 角色：例如"管理员"，"普通用户"
- 动作：创建/删除/修改
- 数据：使用我们支持"全局数据/实体/关系/属性/实体试图/聚合值"中的类型来表达。例如"用户总数(全局数据)"、"按名称排序的图书列表(实体视图)"
- 业务约束条件(可选)：例如："不能读被封禁的图书的详细内容"
- 数据约束(可选)：例如:"创建员工信息时，自动连带创建制服信息"。"删除书架时，连带删除所有书架上书籍信息"

特别注意，"创建"、"修改"、"删除"类会改变数据的需求，一定识别可能的数据约束需求。当然如果没有，也不需要强行加上。

从根的读需求出发，按照这个方法不断衍生迭代，直到需求完备，不再能衍生出新的需求。

注意：我们要把上一步中识别出来的用户输入里的需求，也整合到当前这一步的需求分析结果中。用户的输入中可能是符合我们表达形式的需求，也可能只是约束条件等。


### 📄 创建文档：`requirements-analysis.md`
在这一步，agent应该创建一个需求分析文档，记录所有识别出的需求及其依赖关系。

**文档模板：**
```markdown
# 需求分析

## 根读需求

### R001: [需求名称]
- **目标**: G001
- **角色**: [执行该操作的角色]
- **数据**: [需要读取的数据描述]
- **约束条件**: [需求中的约束条件]

### R002: [需求名称]
- **目标**: [直接服务的目标]
- **角色**: [执行该操作的角色]
- **数据**: [需要读取的数据描述]
- **约束条件**: [需求中的约束条件]

## 衍生需求

### 衍生自 R001

#### R001: [需求名称]
- **衍生自**: R001
- **角色**: [执行该操作的角色]
- **动作**: 创建
- **数据**: [需要创建的数据描述]
- **业务约束条件**: [创建限制或验证规则]
- **数据约束条件**: [业务需求中的数据约束条件]

### 衍生自 R002

#### R201: [需求名称]
- **衍生自**: R002
- **角色**: [执行该操作的角色]
- **动作**: 修改
- **数据**: [需要修改的数据描述]
- **业务约束条件**: [修改限制或验证规则]
- **数据约束条件**: [业务需求中的数据约束条件]

#### R301: [需求名称]
- **衍生自**: R002
- **角色**: [执行该操作的角色]
- **动作**: 删除
- **数据**: [需要删除的数据描述]
- **业务约束条件**: [删除限制或条件]
- **数据约束条件**: [业务需求中的数据约束条件]
```


## 3. 数据概念提取

从需求中提取出所有必须的数据概念，用当前分析框架中支持的数据类型来表达。
对于聚合值，要显式地表达数据依赖。

### 3.1 实体识别与分析

从需求中提取名词作为潜在实体：
- 识别主要业务对象
- 确定需要持久化和跟踪的数据
- 识别具有独特身份和生命周期的对象

### 3.2 属性分析

对每个实体的每个属性进行分析：
- **名称**: 名称
- **类型**: string|number|boolean|others
- **计算方式**: 如果是聚合值或者计算值，要描述具体的聚合或者计算方式
- **数据依赖**: 如果是聚合值或者计算值，列出该属性计算所依赖的其他数据

### 3.3 关系识别与分析

从需求中的动词短语识别关系：
- 确定关系类型（1:1、1:n、n:1、n:n）
- 分析关系的生命周期
- 识别关系的属性

### 3.4 全局数据（字典）识别

识别系统级别的数据：
- 不属于任何特定实体实例的数据
- 系统级统计或聚合
- 全局配置或设置

### 📄 创建文档：`data-concept-extraction.md`
在这一步，agent应该创建一个数据建模文档，使用JSON格式记录所有数据模型。
// TODO 根据上面新的结构补充模板

## 4. 交互动作设计

一个需求通常对应一个交互动作来完成，也有可能对应多个交互动作，具体看业务场景来分析。

设计系统可执行的交互动作是为了来满足需求的。它的表达形式为：
```json
{
    condition: {交互动作的限制条件},
    role: {角色},
    action: {动作名称},
    payload: {负载信息. optional},
    data: {当前需求中表达的数据. optional}
    dataContraints: {从满足的需求中继承的数据约束}
}
```

注意：交互动作中使用的数据，应该全部都是数据建模中表达出来的数据，不应该在交互动作设计中出现新的数据概念。
如果当前满足的需求是有数据约束的，那么在交互动作设计中，一定要完整的继承数据约束。

### 📄 创建文档：`interactions-design.md`
在这一步，agent应该创建一个交互设计文档，记录所有系统交互。

**文档模板：**
```markdown
# 交互动作设计

## 交互列表

### I001: [交互名称]
- **对应需求**: R101
- **角色**: [执行该交互的角色]
- **动作类型**: [创建/修改/删除/查询]
- **前置条件**: 
  - [条件1]
  - [条件2]
- **输入数据** (payload):
  ```json
  {
    "field1": "string - 描述",
    "field2": "number - 描述"
  }
  ```
- **影响的数据**:
  - 创建: [Entity1, Relation1]
  - 修改: [Entity2.property1]
  - 删除: [Relation2]
- **业务规则**:
  - [规则1]
  - [规则2]
- **预期结果**: [描述交互成功后的系统状态变化]

### I002: [交互名称]
[按照相同格式继续]
```

